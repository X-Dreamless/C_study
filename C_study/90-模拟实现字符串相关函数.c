/*
	实用调试技巧
		什么是bug？
		调式是什么？有多重要？
		debug和release的介绍
		Windows环境调试介绍
		一些调试的实例
		如何写出好(易于调试)的代码
		编程常见的错误

		======== ======== ======== ======== ========
		-------- -------- -------- -------- --------

		什么是bug？
			第一次被发现的导致计算机错误的飞蛾，也是第一个计算机程序错误

		-------- -------- -------- -------- --------

		调式是什么？有多重要？
			所有发生的事情都有一定有迹可循，如果问心无愧，就不需要掩盖也就没有迹象了，如果问心有愧
			，就必然需要掩盖，那就一定会有迹象，迹象越多就越容易顺藤而上，这就是推理的途径。
			顺着这条途径顺流而下就是犯罪，逆流而上，就是真相。

			一名优秀的程序员是一名出色的侦探
				每一次调试都是尝试破案的过程

			调试是什么？
				调试(debugging/debug)，又称除错，是发现和减少计算机程序或电子仪器设备中程序错误的一个过程

			拒绝迷信式调试！

			调试的基本步骤
				发现程序错误的存在
				以隔离、消除等方式对错误进行定位
				确定错误产生的原因
				提出纠正错误的解决办法
				对程序错误予以改正，重新测试

		-------- -------- -------- -------- --------

		debug和release的介绍
			debug 通常称为调试版本，它包含调试信息，并且不做任何优化，便于程序员调试程序

			release 称为发布版本，它往往是进行了各种优化，使得程序在代码大小和运行速度上都是最优的，以便用户很好地使用

		-------- -------- -------- -------- --------

		Windows环境调试介绍
			注：Linux开发环境调试工具是gdb

			1.调试环境的准备
				解决方案配置改成debug

			2.学会快捷键
				最常用的几个快捷键
					F5
						启动调试，经常用来直接跳到下一个断点处

					F9
						创建断点和取消断点，可以在程序的任意位置设置断点。这样就可以使得程序在想要的位置随意停止执行
						，继而一步步执行下去。

						点击某行代码再按F9

						断点可以设置条件，比如x == 5。满足条件触发断点

					F10
						逐过程，通常用来处理一个过程，一个过程可以是一次函数调用，或者是一条语句。

					F11
						逐语句，就是每次都执行一条语句，但是这个快捷键可以使我们的执行逻辑进入函数内部(这是最常用的)

					CTRL + F5
						开始执行不调试，如果你想让程序直接运行起来而不调试就可以直接使用

			3.调试的时候查看程序当前信息
				查看临时变量的值

				监视窗口可以添加表达式 可以添加寄存器

				自动窗口会自动 添加和删除 变量

				内存窗口 左边是地址 中间是内存数据 右边是翻译文本

				调用堆栈 函数的调用逻辑 栈=堆栈

		-------- -------- -------- -------- --------

		一些调试的实例
			解决问题时，对代码执行有预期，调试的时候发现不符合预期就找到问题了

			int main()
			{
				int i = 0;
				int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
				for (i = 0; i <= 12; i++)
				{
					arr[i] = 0;// 运行时检查失败#2-变量“arr”周围的堆栈已损坏。
					printf("hehe\n");
				}

				return 0;
			}

			i和arr是局部变量
			局部变量是放在栈区上的

			1.栈内存的使用习惯是：先使用高地址空间，再使用低地址空间

			2.数组随着下标的增长，地址是由低到高变化的

				高地址	-----
						| i |	12		这是VS 给i分配的空间地址在数组后面后移两个int位置的地方就是i的地址。
						-----
						| * |	11		越界访问可能就会修改到i的值造成死循环
						-----
						| * |	10		VC6.0h环境	中间空 0个整形
						-----			gcc环境		中间空 1个整形
						| 9 |			VS2013-2019	中间空 2个整形
						-----
						| 8 |			题目来源《C陷阱和缺陷》
						-----
						| 7 |
						-----
						| 6 |
						-----
						| 5 |
						-----
						| 4 |
						-----
						| 3 |
						-----
						| 2 |
						-----
						| 1 |
						-----
						| 0 |	下标从0开始
				低地址	-----

			推荐书籍
				《明解C语言》初级-进阶
				《C和指针》
				《C陷阱和缺陷》
				《C语言深度解剖》

				《谭浩强C语言》通俗易懂 但是代码风格很差 - 看语法 不模仿代码

		-------- -------- -------- -------- --------

		如何写出好(易于调试)的代码
			优秀的代码
				1.代码运行正常
				2.bug很少
				3.效率高
				4.可读性高
				5.可维护性高
				6.注释清晰
				7.文档齐全

			常见的coding技巧
				1.使用assert(断言)
				2.尽量使用const
				3.养成良好的编码风格
				4.添加必要的注释
				5.避免编码的陷阱

		-------- -------- -------- -------- --------

		编程常见的错误

		-------- -------- -------- -------- --------
*/

#include "define.h"

/*
	strcpy()有两个参数
		1.目标空间的起始地址
		2.源空间的起始地址

	strcpy()拷贝的时候\0也会拷贝过去

	const 修饰变量，这个变量就被称为常变量，不能被修改，但本质上还是变量
*/

#include <stdio.h>
#include <assert.h>

// 模拟实现库函数：strcpy
void 字符串拷贝1(char* 目标, char* 源)
{
	while (*源 != '\0')
	{
		*目标 = *源;
		目标++;
		源++;
	}
	*目标 = *源;// 循环结束后拷贝\0
}

void 字符串拷贝2(char* 目标, char* 源)
{
	while (*源 != '\0')
	{
		*目标++ = *源++;// 目标++;源++;本来就是拷贝完成后++，改成后置++，先使用再++
	}
	*目标 = *源;// 循环结束后拷贝\0
}

void 字符串拷贝3(char* 目标, char* 源)
{
	while (*目标++ = *源++)// \0的ascii码是0，0为假停止循环，表达式结果为0停止循环
	{
		;
	}
}

void 字符串拷贝4(char* 目标, char* 源)
{
	// 空指针不能进行解引用操作
	assert(源 != NULL);// 断言，条件为假 程序报错 显示错误行数
	assert(目标 != NULL);
	while (*目标++ = *源++)// \0的ascii码是0，0为假停止循环，表达式结果为0停止循环
	{
		;
	}
}

// 把 源 指向的内容拷贝放进 目标 指向的空间中
// 从本质上讲，希望 目标 指向的内容被修改，源 指向的内容不应该被修改
void 字符串拷贝5(char* 目标, const char* 源)// 加上const修饰变量，所修饰的数据类型的变量或对象的值是不能被改变的
{
	// 空指针不能进行解引用操作
	assert(源 != NULL);// 断言，条件为假报错
	assert(目标 != NULL);
	while (*目标++ = *源++)// 上面加上const后这里写反了编译器会报错
	{
		;
	}
}

// strcpy()这个库函数其实返回的是目标空间的起始地址，拷贝完成后返回
char* 字符串拷贝(char* 目标, const char* 源)
{
	assert(源 != NULL);
	assert(目标 != NULL);
	char* ret = 目标;
	while (*目标++ = *源++)
	{
		;
	}

	//return 目标;// 不能这样写，因为上面++了很多次 不是起始地址了
	return ret;
}

int main()
{
	char arr1[20] = "xxxxxxxxxx";
	char arr2[] = "hello";
	字符串拷贝(arr1, arr2);
	//printf("%s\n", arr1);
	printf("%s\n", 字符串拷贝(arr1, arr2));// 链式访问，一个函数的 返回值 作为另一个函数的 参数 


	// https://www.bilibili.com/video/BV1cq4y1U7sg?p=93
	// 46:00 凉皮男孩
	// 
	// 这样可以修改const修饰的变量
	//const int num = 10;
	//int* p = &num;
	//*p = 20;
	//printf("%d\n", num);

	// const 如果放在*的左边，修饰的是*p，表示指针指向的内容不能通过指针来改变，但是指针变量本身是可以修改的
	//const int num = 10;
	//const int* p = &num;
	////*p = 20;
	// p = 100;
	//printf("%d\n", num);

	// 但是二级指针可以修改
	//const int num = 10;
	//const int* p = &num;
	//int** pp = &p;
	//**pp = 20;
	//printf("%d\n", num);

	//const 放在*的右边，修饰的是指针变量p，表示指针变量不能被改变，但是指针指向的内容可以改变
	//const int num = 10;
	//int* const p = &num;
	//int n = 100;
	//*p = 20;
	// p = &n;
	//printf("%d\n", num);

	return 0;
}