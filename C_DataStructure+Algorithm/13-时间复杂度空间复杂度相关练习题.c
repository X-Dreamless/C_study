/*
	5. 复杂度的oj练习

		消失的数字
			数组nums包含从0到n的所有整数，但其中缺了一个，请编写代码找出那个缺失的整数。
			O(N)时间内完成。

			示例1：
				输入：[3,0,1]
				输出：2

			示例2：
				输入：[9,6,4,2,3,5,7,0,1]
				输出：8


			思路1：
				排序 -> 库函数qsort快排( 时间复杂度O(n*log(2)N) )
				后一个数是不是前一个数+1得到的

			思路2：
				循环 -> (0+1+2+3+......+n) - (a[0] + a[1] + a[2] + ...... + a[n-1])
				相减后，可直接得到数组中缺少的数
				时间复杂度O(N)
				空间复杂度O(1)

			思路3：
				创建 n+1 个数的数组
				[ ][ ][ ][ ][ ][ ][ ][ ][ ][ ]
				 0  1  2                    n

				输入：[9,6,4,2,3,5,7,0,1]

				放元素，数组中值是几 就在第几个位置放这个元素

				[0][1][2][3][4][5][6][7][ ][9]
				 0  1  2  3  4  5  6  7  8  n

				看哪个位置没放

				空间复杂度O(N)
				时间复杂度O(N)

			思路4：
				给一个 x = 0
				x 先和 0 到 n 的所有值异或
				x 再和 数组中每个值异或，最后x就是缺的那个数字

				两个相同的数 异或 得0

				这样异或不需要考虑顺序

				异或运算三个性质：
					任何数和 0做异或运算，结果仍然是原来的数
					任何数和其自身做异或运算，结果是 0
					异或运算满足交换律和结合律

				时间复杂度O(N)
				空间复杂度O(1)

		-------- -------- -------- -------- -------- -------- --------

		旋转数组
			给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。
			空间复杂度O(1)的 原地 算法。

			示例 1:
				输入: nums = [1,2,3,4,5,6,7], k = 3
				输出: [5,6,7,1,2,3,4]
				解释:
				向右轮转 1 步: [7,1,2,3,4,5,6]
				向右轮转 2 步: [6,7,1,2,3,4,5]
				向右轮转 3 步: [5,6,7,1,2,3,4]

			示例 2:
				输入：nums = [-1,-100,3,99], k = 2
				输出：[3,99,-1,-100]
				解释:
				向右轮转 1 步: [99,-1,-100,3]
				向右轮转 2 步: [3,99,-1,-100]

			提示：
				1 <= nums.length <= 105
				-231 <= nums[i] <= 231 - 1
				0 <= k <= 105


			思路1：
				暴力求解，旋转k次
				每次旋转借助一个临时变量，保存值
				移动n-1次
				再把临时变量的值放进去

				每次旋转是n，旋转k次

				时间复杂度O(N*k)
				空间复杂度O(1)

			思路2：
				开辟额外空间
				以空间换时间
									  k k k
				输入: nums = [1,2,3,4,5,6,7], k = 3

							  k k k
				拷贝：tmps = [5,6,7,1,2,3,4]

				时间复杂度O(N)
				空间复杂度O(N)

			思路3：
				三步翻转法

				输入: nums = [1,2,3,4,5,6,7], k = 3
				输出: [5,6,7,1,2,3,4]

				↓ ↓ ↓ ↓
				4 3 2 1 5 6 7 前n-k个逆置

				        ↓ ↓ ↓
				4 3 2 1 7 6 5 后k个逆置


				5 6 7 1 2 3 4 整体逆置

				时间复杂度O(N)
				空间复杂度O(1)


		演示&讲解
			消失的数字_思路4_异或(arr, sz);
			旋转数组_三步翻转法();
*/

#include "My_function.h"

int 消失的数字_思路4_异或(int* nums, int numsSize)
{
	int x = 0;

	// x 先和 0 到 n 的所有值异或
	for (int i = 0; i <= numsSize; ++i)// <= 有10个数
	{
		x ^= i;
	}

	// x 再和 数组中每个值异或
	for (int i = 0; i < numsSize; ++i)// < 有9个数
	{
		x ^= nums[i];
	}

	// 最后x就是缺的那个数字
	return x;
}

/*-------- -------- -------- -------- -------- -------- --------*/

void 逆置(int* nums, int 左, int 右)
{
	while (左 < 右)
	{
		int tmp = nums[左];
		nums[左] = nums[右];
		nums[右] = tmp;
		++左;
		--右;
	}
}

void 旋转数组_三步翻转法(int* nums, int numsSize, int k)
{
	// k == numsSize 时相当于没有旋转
	if (k >= numsSize)
	{
		k %= numsSize;
	}

	// 前n - k个逆置
	逆置(nums, 0, numsSize - k - 1);

	// 后k个逆置
	逆置(nums, numsSize - k, numsSize - 1);

	// 整体逆置
	逆置(nums, 0, numsSize - 1);
}

int main()
{
	int arr[] = { 9,6,4,2,3,5,7,0,1 };
	int sz = sizeof(arr) / sizeof(arr[0]);
	printf("%d\n", 消失的数字_思路4_异或(arr, sz));

	int arr2[] = { 1,2,3,4,5,6,7 };
	int sz2 = sizeof(arr2) / sizeof(arr2[0]);
	旋转数组_三步翻转法(arr2, sz2, 3);

	return 0;
}