/*
	指针进阶
		9.指针和数组面试题的解析

			笔试题1()
			笔试题2()
			笔试题3()
			笔试题4()
			笔试题5()
			笔试题6()
*/

#include "define.h"

void 笔试题1()
{
	int a[5] = { 1,2,3,4,5 };
	int* ptr = (int*)(&a + 1);
		// &a取出的是int(*)[5]这样的数组指针类型，(&a + 1)跳过一个数组，再把跳过后的地址强制类型转换成int*，指针类型发生了变化，

	printf("%d,%d", *(a + 1), *(ptr - 1));
		// (ptr - 1)向前移动1个整形，4个字节，结果是元素5
		// a是数组首元素地址，元素1的地址，1的地址+1，跳过了1，指向了元素2的地址，*(a + 1)解引用找到了元素2
		// 答案是：2，5
}

/**************************************************************************************************************************************************/

struct Test
{
	// 由于还没学习结构体，这里告知这个结构体的大小是20个字节
	int Num;
	char* pcName;
	short sDate;
	char cha[2];
	short sBa[4];
}*p;
void 笔试题2()
{
	// 假设p的值为0x100000，如下表达式的值分别是多少？
	// 已知，结构体Test类型的变量大小是20个字节
	// 题目考察的是：指针类型决定了指针的运算，加减整数
	// 0x1 = 1

	printf("%p\n", p + 0x1);
		// 指针变量+1到底加多少，取决于指针的类型，这里是结构体指针，跳过的是一个结构体，加的是20个字节，十六进制0x100000变成0x100014

	printf("%p\n", (unsigned long)p + 0x1);
		// p不管原来是什么类型，强制类型转换成unsigned long，无符号长整形，整形+1加的就是1，结果为0x100001

	printf("%p\n", (unsigned int*)p + 0x1);
		// 强制类型转换成unsigned int*，此时这个指针被理解为指向的是一个无符号整形，+1跳过一个整形变量，加的是4个字节，结果为0x100004
}

/**************************************************************************************************************************************************/

void 笔试题3()
{
	int a[4] = { 1,2,3,4 };
	int* ptr1 = (int*)(&a + 1);
		// &a取出的是数组的地址，数组地址+1跳过一个数组，强制类型转换成int*，跳过后的值赋值给ptr1，

	int* ptr2 = (int*)((int)a + 1);
		// 数组名是首元素地址，元素1的地址，然后强制类型转换成整形，然后+1，整形+1就是+1(例如1+1=2)，这里+1跳过1个字节
		// 假设有地址0x00000001 转换成 整形 后+1 得0x00000002
		// int*   int     int  int*
		// 0x20 → 32 +1 = 33 → 0x21
		// 
		//				&a											    &a+1
		//				↓											      ↓
		// 按照小端存储:[01 00 00 00  02 00 00 00  03 00 00 00  04 00 00 00]
		//                 ↑                                   ↑
		//                (int)a+1 赋值给→ ptr2               ptr1-1

	printf("%x, %x", ptr1[-1], *ptr2);// 引发了异常: 读取访问权限冲突。ptr2 是 0x670FF9D9。
		// %x 十六进制格式打印
		// ptr1[-1]可以转换成，ptr1+(-1)再括号括起来解引用*(ptr1+(-1))，等于*(ptr1-1)。
		// ptr1-1 整形指针-1移动4个字节，*(ptr1-1) 解引用向后访问4字节，真实读取出来是0x00 00 00 04
		// 
		// 对整形指针ptr2解引用，向后访问4字节，00 00 00  02，真实读取出来是0x02 00 00 00
		// 
		// 答案是：0x00 00 00 04, 0x02 00 00 00
		//         (4)            (2000000)
}

/**************************************************************************************************************************************************/

void 笔试题4()
{
	int a[2][3] = { (0, 1),(2, 3),(4, 5) };
		// 将0和1放在第一行应该用大括号{0,1}
		// 小括号()里面是逗号表达式，逗号表达式结果是最后一个
		//								1.从左到右逐个计算；
		//								2.逗号表达式作为一个整体，它的值为最后一个表达式的值；
		//								3. 逗号表达式的优先级别在所有运算符中最低。
		// 这相当于数组里就放了1，3，5
		//					   0   1
		//					0 [1] [3]
		//					1 [5] [0]
		//					2 [0] [0]

	int* p;
	p = a[0];
		// a[0]第一行数组名，没有取地址，没有放到sizeof()里，所以这里的数组名就是首元素地址，元素1的地址

	printf("%d", p[0]);
		// p[0]等价于*(p+0)
		// 答案是：1
}

/**************************************************************************************************************************************************/

void 笔试题5()
{
	int a[5][5];
		// 
		//		a[0]	   |	  a[1]		 |		a[2]	   |	  a[3]		 |		a[4]
		//	0  1  2  3  4  |  0  1  2  3  4  |  0  1  2  3  4  |  0  1  2  3  4  |  0  1  2  3  4
		//                                                           0  1  2  3
		// [ ][ ][ ][ ][ ] , [ ][ ][ ][ ][ ] , [ ][ ][ ][ ][ ] , [ ][ ][ ][ ][ ] , [ ][ ][ ][ ][ ]
		// ↑		   ↑		      ↑				 ↑				↑     ↑	   ↑		 ↑
		// a		   |		      |				 |				|     |	   |	 &a[4][2]
		// ↑           |              |              |              |     |    |
		// p          p+1            p+2            p+3            p+4    |    |
		//														  (p+4)→→→┼→*(p+4)
		//															      |
		//															   p[4][2]
		//                                                           *(*(p+4)+2)

	int(*p)[4];
		// p是指针，指向的是数组，指向的数组有4个元素，每个元素类型是int
		// 站在p的角度，p认为：指向的数组有4个元素，每个元素类型是int

	p = a;
		// a是数组名，二维数组的数组名是第一行的地址，a作为地址类型是int(*)[5]
		// p的类型是int(*)[4]，p和a有差异
		// (警告	C4048	“int(*)[4]”和“int(*)[5]”数组的下标不同	Project1	D : \ruchuruo\C\01\Project1\124 - 指针练习2讲解.c	131)

	printf("%p,%d\n", &p[4][2] - &a[4][2], &p[4][2] - &a[4][2]);
		// *(p+4)等价于p[4]，(p+4)解引用后向后访问数组，4个元素
		// p[4][2]可以理解为*(*(p+4)+2)
		// 指针和指针相减得到 指针和指针 之间元素的个数，小地址减大地址得到负数
		// 
		// -4 原码 10000000 00000000 00000000 00000100
		// -4 反码 11111111 11111111 11111111 11111011
		// -4 补码 11111111 11111111 11111111 11111100
		// 
		// 如果是补码%d形式打印，认为内存中放的是有符号的整数，求出原码再打印
		// 如果是补码%p形式打印，认为内存中放的是地址，地址没有正负之分，内存中的补码直接会被当成原码拿出来，也就是在这补码就是它的真实值
		// 
		// 答案是：FFFFFFFFFFFFFFFC,-4
}

/**************************************************************************************************************************************************/

void 笔试题6()
{
	int aa[2][5] = { 1,2,3,4,5,6,7,8,9,10 };
		// 
		//		   ptr2-1			 ptr1-1
		//			   ↓				 ↓
		// [1][2][3][4][5] , [6][7][8][9][10] [ ]
		// ↑				 ↑				  ↑
		// &aa			   aa+1			   &aa+1
		//									  ↑
		//								    ptr1

	int* ptr1 = (int*)(&aa + 1);
	int* ptr2 = (int*)(*(aa + 1));
		// 
		// aa是数组名，没有单独放到sizeof里，没有取地址，这里aa表示首元素地址，第一行的地址，二维数组的数组名表示第一行的地址
		// *(aa + 1)等价于a[1]，aa+1跳过第一行，指向第二行
		// 写成a[1]相当于第二行的数组名，第二行数组名相当于 第二行第一个元素的地址，元素6的地址
		// *(aa + 1)解引用后，拿到了元素6的地址，元素6的地址本身就是整形的地址，强制类型转换int*就是迷惑你

	printf("%d,%d", *(ptr1 - 1), *(ptr2 - 1));
		// ptr1是整形，整形-1向前跳过4字节，指向的是元素10的地址，解引用后找到元素10
		// 
		// 答案是：10,5
}

int main()
{
	笔试题1();

	笔试题2();

	//笔试题3();// 引发了异常: 读取访问权限冲突。ptr2 是 0x670FF9D9。

	笔试题4();

	笔试题5();

	笔试题6();

	return 0;
}