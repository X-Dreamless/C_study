/*
	编码的三种境界：
		1.看代码就是代码
		2.看代码就是内存
		3.看代码还是代码(编程像说话一样流畅)

	指针进阶
		1.字符指针
		2.数组指针
		3.指针数组
		4.数组传参和指针传参
		5.函数指针
		6.函数指针数组
		7.指向函数指针数组的指针
		8.回调函数
		9.指针和数组面试题的解析

		======== ======== ======== ======== ========

		指针初阶我们知道了指针的概念
			1.指针就是个变量，用来存放地址，地址唯一标识一块内存空间
			2.指针的大小是固定的4/8个字节(32位平台/64位平台)
			3.指针是有类型，指针的类型决定了指针的+-整数的步长，指针解引用操作的时候的权限
			4.指针的运算

		======== ======== ======== ======== ========

		1.字符指针
			char*

			一般使用
				char ch = 'w';
				char* pc = &ch;
				*pc = 'w';

			还有一种
				// 本质上是把"hello bit"这个字符串的首字符的地址存储在了ps中
				// 和char arr[] = "hello bit";不同，这种写法一定是把"hello bit"这个字符串放在了arr里
				char* ps = "hello bit";
				char arr[] = "hello bit";
				printf("%c\n", *ps);// h
				printf("%s\n", ps);// 打印字符串的时候给个起始位置的地址就能打印出来了
				printf("%s\n", arr);


			后面的hello bit.是常量字符串
				char* str3 = "hello bit.";

				严格写法
					const char* str3 = "hello bit.";
					虽然是常量字符串，但是*str3 = 'w';不会报错，加上const就会显示报错，语法更严谨

					const放在*的左边修饰的是指针指向的内容不能被修改

					(左边指向内容不能被修改,右边指向地址不能被修改)

		-------- -------- -------- -------- --------

		2.数组指针

			整形指针 指向整形的指针
			字符指针 指向字符的指针

			数组指针的定义
				数组指针是指针

				数组指针是 能够指向数组的指针

			定义一个数组指针
				int (*parr)[10];

				讲解在
					数组指针()

			&数组名 和 数组名

				&arr表示的是数组的地址，而不是数组首元素地址
				arr数组名是数组首元素的地址

				讲解在
					数组指针2_取地址数组名和数组名()

			数组指针的使用
				既然数组指针指向的是数组，那数组指针中存放的应该是数组的地址

				一般不会在一维数组中使用

				讲解在
					数组指针3_数组指针的使用_一维数组()
					数组指针4_数组指针的使用_二维数组()

		-------- -------- -------- -------- --------

		3.指针数组
			指针数组是一个存放指针的数组

			复习：
				int* arr[10];	// 整形指针的数组
				char* arr2[4];	// 一级字符指针的数组
				char** arr3[5]	// 二级字符指针的数组

			讲解在
				指针数组()
				指针数组2()

		-------- -------- -------- -------- --------

		4.数组传参和指针传参

			一维数组传参
				void test(int arr[]){}
				void test(int arr[10]){}
				void test(int *arr){}
				void test(int *arr[20]){}//20可以省略
				void test(int **arr){}

				int main()
				{
					int arr[10] = { 0 };
					int* arr2[20] = { 0 };
					test(arr);
					test2(arr2);
				}

			二维数组传参
				void test(int arr[3][5]){}
				void test(int arr[][]){}	// 错，行可以省略，列不能省略
				void test(int arr[3][5]){}
				void test(int *arr){}		// 错，传过来的是第一行的地址，一维数组的地址，不能拿一级指针接收
				void test(int *arr[5]){}	// 错，形参部分是一个数组，不是指针
				void test(int (*arr)[5]){}
				void test(int **arr){}		// 错，传过来的不是二级指针

				int main()
				{
					int arr[3][5] = { 0 };
					test(arr);
				}

			不管是一维还是二维数组，一定要分清传过去的是什么，接收的又是什么，两者要对应



			一级指针传参
				指针变量传参 指针变量接收

				char ch = 'w';
				char* pc = &ch;

				test(&ch);// ch是一个char类型的变量，取它的地址，它的类型就是char*
				或
				test(pc);

				一级指针传参，一级指针接收

				讲解在
					一级指针传参()

				一级指针
					int* p;		整形指针，指向整形的指针
					char* pc;	字符指针，指向字符的指针
					void* pv;	无类型的指针

			二级指针传参
				二级指针传参，二级指针接收

				讲解在
					二级指针传参()


		-------- -------- -------- -------- --------

		5.函数指针
			指向函数的指针
			存放函数地址的指针

			&函数名，取到的就是函数的地址

			数组名 != &数组名
			函数名 == &函数名

			函数没有首元素地址

			讲解在
				函数指针()
				函数指针2()

		-------- -------- -------- -------- --------

		6.函数指针数组
			把函数的地址存到一个数组中，那这个 数组 就叫函数指针数组

			定义一个函数指针数组
				int (*pfArr[2])(int, int) = { 函数名1, 函数名2 };

			前提是 数组里所有的函数 返回类型，参数 都是统一的才能实现

			讲解在
				函数指针数组()
				函数指针数组2_计算器()
				函数指针数组2_计算器2()

			计算器2 分析
				给一个下标
				通过下标找到数组里面的某个元素
				那个元素是一个函数的地址
				然后调用那个函数，那个地址对应的函数

				这好像起到了一个跳板的作用，跳转的作用
				通过下标找到元素，通过这个元素直接调用函数

			这样的数组也可也叫做
				转移表
				这个概念在《C和指针》里有提到

		-------- -------- -------- -------- --------

		7.指向函数指针数组的指针
			指向函数指针数组的指针 是一个 指针，指针指向一个数组，数组的元素都是函数指针

			函数指针					int (*p)(int, int) = &函数名;
			函数指针的数组			int (*p2[4])(int, int) = { 函数名1, 函数名2 };
			指向函数指针数组的指针	int (*(*p3)[4])(int, int) = &p2;
										p3旁边的*说明它是指针
										向外一看，发现[4]，指向的是数组，4个元素
										将(*p3)[4]去掉，剩下的就是函数指针类型，int (*)(int, int)
										现在p3就是 指向函数指针数组的指针

		-------- -------- -------- -------- --------

		8.回调函数
			回调函数就是一个通过函数指针调用的函数。如果你把函数的指针(地址)作为参数传递给另一个函数，
			当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。
			回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，
			由于对该事件或条件进行响应。

			讲解在
				回调函数_计算器()

		-------- -------- -------- -------- --------
		======== ======== ======== ======== ========

		数组名是数组首元素的地址
		但是有2个例外，只有这2个例外
			1.sizeof(数组名) - 数组名表示整个数组，计算的是整个数组大小，单位是字节
			2.&数组名 - 数组名表示整个数组，取出的是整个数组的地址

		int arr[10]
			数组元素类型		int
			arr数组的类型	int [10]

			C 语言中的 数据类型 分为 基础数据类型，非基础数据类型
			数组类型 由 元素类型 和 元素个数 共同决定，
			int arr[10] 的数据类型是 int [10]，其中 int 是元素类型，[10] 是元素个数


		int arr[5];				整形数组
		int *parr1[10];			指针数组
		int (*parr2)[10];		数组指针，该指针能够指向一个数组，数组10个元素，每个元素的类型是int
		int (*parr3[10])[5];	parr3是一个存放数组指针的数组，该数组能存放10个数组指针，每个数组指针能指向一个数组，数组5个元素，每个元素是int类型。
								挖掉parr3[10]剩下的就是这个数组parr3里面元素的类型。

		阅读两段有趣的代码
			代码1
				(*(void(*)())0)();

				0是数字
				函数的地址打印出来也是数字 比如：0x0066CCFF，是个地址，是个编号
				0x0066CCFF这个数字要成为地址，必须是一种指针类型
				如果希望0x0066CCFF是一个函数的地址，需要把它转换成函数的类型
				0是数字，只要把他转换成一种函数指针类型，0就被看作是一个函数的地址

				将0强制类型转换成void(*)()函数指针类型，(void(*)())0
				如果有p，void(*p)()是一个函数指针变量
				没有p，void(*p)()是一个函数指针类型
				将0强制类型转换成函数指针类型之后，0就当成这个类型的一个函数的地址
				(void(*)())0调用函数，在前面加*，再括起来(*(void(*)())0)，就相当于找到了0地址的函数，然后调用(*(void(*)())0)();
				因为0地址放到的函数是无参数的所以调用的时候不传参数

				调用0地址处的函数，该函数无参，返回类型是void

				1.void(*)()			函数指针类型
				2.(void(*)())0		对0进行强制类型转换，被解释为一个函数地址
				3.*(void(*)())0		对0地址进行解引用操作
				4.(*(void(*)())0)() 调用0地址处的函数

				代码出自：《C陷阱和缺陷》

				这里只是分析代码
				将0改成0x0066CCFF，(*(void(*)())0x0066CCFF)();这个代码从语法层次上是没问题，
				但是，任何一个内存空间的地址不是随便想象出来的，内存空间分配是由编译器决定的，
				我们不知道编译器给我们分配的什么地址，这一次是0x0066CCFF，下一次可能是0x0000FFFF，
				代码里面固定写死的话，代码存在问题，
				很少会对这样的常量的值作为地址来使用，
				0地址在《C陷阱和缺陷》里别人的机器里，就是把这个函数放在0位置，
				我们尽量不要写出这样的代码

			代码2
				void(*signal(int, void(*)(int)))(int);

				例如定义函数void test(){}，函数名test和后面的()先结合，说明一定是函数
				signal(int, void(*)(int))，signal是函数名，
											第一个参数是int，
											第二个参数是void(*)(int)函数指针类型
				void(*)(int)，函数指针类型

				1.signal和()先结合，说明signal是函数名
				2.signal函数的第一个参数的类型是int，第二个参数的类型是函数指针
					该函数指针，指向一个参数为int，返回类型是void的函数
				3.signal函数的返回类型也是一个函数指针
					该函数指针，指向一个参数为int，返回类型是void的函数
					signal是一个函数的声明

				简化代码
					void(*)(int) signal(int, void(*)(int))，这样写虽然好理解，但是语法不支持
					void(*signal(int, void(*)(int)))(int)， *必须和名字放在一起，但是和原本的没区别了

					typedef 对类型进行重定义，重命名

					typedef void(*)(int) pfun_t，但是不能这样写，语法不支持
					typedef void(*pfun_t)(int);//名字和*放在一起，对void(*)(int)的函数指针类型 重命名为pfun_t，pfun_t等价于void(*)(int)

					pfun_t signal(int, pfun_t);// 简化完成

				写法1：	void(*signal(int, void(*)(int)))(int);
				写法2：	typedef void(*pfun_t)(int);
						pfun_t signal(int, pfun_t);

		指针的类型只是决定了步长与读取能力
*/

#include "define.h"

void 文档底部();

void n(int y)
{
	int i = 0;
	for (i = 0; i < y; i++)
	{
		printf("\n");
	}
}

//题目
//以下程序运行结果是什么？
void 题目1()
{
	printf("%s\n", "题目1");

	char str1[] = "hello bit.";
	char str2[] = "hello bit.";
	char* str3 = "hello bit.";
	char* str4 = "hello bit.";

	if (str1 == str2)// 不相同
	{
		printf("str1 and str2 are same\n");
	}
	else
	{
		printf("str1 and str2 are not same\n");
	}

	if (str3 == str4)// 相同
	{
		printf("str3 and str4 are same\n");
	}
	else
	{
		printf("str3 and str4 are not same\n");
	}

	/*
		str1和str2是两个数组
				  str1 指向的是空间1的
					↓
			空间1	hello bit.
			空间2	hello bit.
					↑
				  str2 指向的是空间2的

		str3和str4
			因为"hello bit."是常量字符串，
			两份相同的数据并且不能改，所以内存中只存一份

				  str3 指向的是空间3的
					↓
			空间3	hello bit.
					↑
				  str4 指向的是空间3的

		严格写法
			const char* str3 = "hello bit.";
			虽然是常量字符串，但是*str3 = 'w';不会报错，加上const就会显示报错，语法更严谨


		题目来自《剑指offer》49页
	*/

	n(1);
}

//章节内容讲解
void 指针数组()
{
	printf("%s\n", "指针数组");

	// 以下这样写应用场景非常少
	int a = 10;
	int b = 20;
	int c = 30;
	int* arr[3] = { &a,&b,&c };//存放整形指针的数组
	int i = 0;
	for (i = 0; i < 3; i++)
	{
		printf("%d ", *(arr[i]));// arr[i]现在是一个地址，括起来然后解引用，就找到了对应的值
	}

	n(2);
}

void 指针数组2()
{
	printf("%s\n", "指针数组2");

	int a[5] = { 1,2,3,4,5 };
	int b[] = { 2,3,4,5,6 };
	int c[] = { 3,4,5,6,7 };

	int* arr[3] = { a,b,c };

	int i = 0;
	for (i = 0; i < 3; i++)
	{
		int j = 0;
		for (j = 0; j < 5; j++)
		{
			//printf("%d ", *(arr[i] + j));// arr[i]+j可以理解为arr[0] = a 里的 下标0的元素
			printf("%d ", arr[i][j]);// 可以写成这样，[j]可以转变为+j解引用
		}
		printf("\n");
	}

	/*
		模拟了二维数组，但是不是二维数组，二维数组里的元素是连续存放的
		现在这样写的里面三行都是独立的，只不过有前面有三个指针(a,b,c)统领起来了，让我们感觉像二维数组
	*/
	n(1);
}

void 数组指针()
{
	printf("%s\n", "数组指针");
	/*
		arr						数组名是首元素的地址 - arr[0]的地址
		&arr					取出的是数组的地址
		int* parr = &arr		这样写不正确，这颗*说明parr是指针，指向的是int
		int* parr[10] = &arr	这样写不正确，parr和[]在一起，parr就是数组了

		int (*parr)[10] = &arr
		正确，
		*和parr在一起说明parr是指针，
		[]表示指向的是一个数组，
		[]里面的10表示指向的数组里面有10个元素，
		int表示指向的数组里面的每个元素是int类型

		现在parr就是一个数组指针

		int (*parr)[10] = &arr
		去掉指针名字parr
		剩下的 int (*)[10] 就是数组指针的类型
	*/
	int arr[10] = { 1,2,3,4,5 };
	double* d[5];// 数组d，[5]有5个元素，每个元素类型是double*

	int(*parr)[10] = &arr;
	double* (*pd)[5] = &d;// *说明pd是指针，[5] 指向的是数组 5个元素，每个元素类型是double*

	n(1);
}

void 数组指针2_取地址数组名和数组名()
{
	printf("%s\n", "数组指针2_取地址数组名和数组名");
	// &数组名 和 数组名

	int arr[10] = { 0 };

	printf("%p\n", arr);
	printf("%p\n", &arr);

	n(1);

	int* p1 = arr;
	int(*p2)[10] = &arr;
	printf("%p\n", p1);
	printf("%p\n", p1 + 1);// 跳过一个整形
	printf("%p\n", p2);
	printf("%p\n", p2 + 1);// 跳过一个数组


	/*
		printf("%p\n", arr);
		printf("%p\n", &arr);
		虽然输出结果一样，但是意义不同
			类型不一样
			就像
				char c = 'a';	//a的Ascll码值是97，char类型
				int i = 97;		//97 int类型

		&arr表示的是数组的地址，而不是数组首元素地址
		arr数组名是数组首元素的地址
	*/
	n(1);
}

void 数组指针3_数组指针的使用_一维数组()
{
	printf("%s\n", "数组指针3_数组指针的使用_一维数组");

	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	int(*pa)[10] = &arr;
	int i = 0;
	for (i = 0; i < 10; i++)
	{
		printf("%d ", *((*pa) + i));
	}

	/*
		*pa对数组指针pa解引用，找到了整个数组，整个数组没法一个个打印
		*pa当他是整个数组的时候，相当于拿到了数组名，*pa相当于数组arr的数组名
		数组名相当于首元素的地址，元素1的地址，通过元素1的地址把所有元素打印出来

		这种写法太别扭

		因为指针*pa存的是arr的地址,解引用找到arr的地址然后解引用+1后的地址
			*((*pa) + i)
			*((arr) + i)
			arr[i]

		(对于数组指针来说，(*p)是取地址，而不是取地址里面的值，*(*p)才是取值)
	*/
	n(2);
}

void 数组指针4_数组指针的使用_二维数组_打印(int(*p)[5], int 行, int 列)
{
	/*
		用指针形式写法的话，这里理所应当的用数组指针
		p是一个数组指针，指向一维数组的，指向二维数组的某一行

		p是指向第一行
		p+i 是指向了某一行，p+0没跳过行，p+1指向了第二行，p+2指向了第三行
		*(p+i)某一行解引用，找到了某一行的数组名

			二维数组的每一行的数组名：
									arr[0]		  arr[1]	   arr[2]
				int arr[3][5] = { {1,2,3,4,5}, {2,3,4,5,6}, {3,4,5,6,7} };
								   ↑
								arr[0]数组名相当于首元素地址

		找到了某一行的首元素地址，然后*(p+i) + j，就找到了下标为j元素的地址
		然后括号括起来(*(p+i) + j)，再解引用*(*(p+i) + j)，就找到了第i行，下标为j的元素
		然后就可以打印出来printf("%d ", *(*(p + i) + j));
	*/
	int i = 0;
	int j = 0;
	for (i = 0; i < 行; i++)
	{
		for (j = 0; j < 列; j++)
		{
			printf("%d ", *(*(p + i) + j));
		}
		printf("\n");// 每行打印完换行
	}
}
void 数组指针4_数组指针的使用_二维数组()
{
	printf("%s\n", "数组指针4_数组指针的使用_二维数组");

	int arr[3][5] = { {1,2,3,4,5}, {2,3,4,5,6}, {3,4,5,6,7} };
	数组指针4_数组指针的使用_二维数组_打印(arr, 3, 5);
	/*
		二维数组的数组名表示 首元素的地址
		二维数组的首元素是：第一行

		第一行是5个整形的一维数组
		二维数组的第一行的地址就是一个一维数组的地址

		假设一维数组名字为 a，int a[5];
		相当于拿到了 &a

		形参就可以写成 int(*p)[5]
	*/
	n(1);
}

void 一级指针传参_打印(int* ptr, int sz)
{
	int i = 0;
	for (i = 0; i < sz; i++)
	{
		printf("%d ", *(ptr + i));
	}
}
void 一级指针传参()
{
	printf("%s\n", "一级指针传参");

	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	int* p = arr;
	int sz = sizeof(arr) / sizeof(arr[0]);

	// p是一级指针
	一级指针传参_打印(p, sz);

	/*
		指针变量传参 指针变量接收

		char ch = 'w';
		char* pc = &ch;

		test(&ch);// ch是一个char类型的变量，取它的地址，它的类型就是char*
		或
		test(pc);

		一级指针传参，一级指针接收
	*/

	n(2);
}

void 二级指针传参_test(int** p2)
{
	**p2 = 20;// *p2解引用找到pa，**p2再解引用找到a
}
void 二级指针传参()
{
	printf("%s\n", "二级指针传参");

	int a = 10;
	int* pa = &a;	// pa是一级指针
	int** ppa = &pa;// ppa是二级指针

	二级指针传参_test(ppa);
	/*
		// 以下都行
		二级指针传参_test(&pa);// 传一级指针变量的地址

		int* arr[10] = { 0 };// 存放整形指针的数组，每个元素类型是int*
		二级指针传参_test(arr);// 传存放一级指针的数组
	*/
	printf("%d\n", a);

	n(1);
}

int 函数指针_Add(int x, int y)
{
	return x + y;
}
void 函数指针()
{
	printf("%s\n", "函数指针");

	printf("%p\n", &函数指针_Add);// &函数名，取到的就是函数的地址
	printf("%p\n", 函数指针_Add);

	int (*pf)(int, int) = &函数指针_Add;// pf就是一个函数指针变量

	int ret = (*pf)(3, 5);// 调用 传参，ret变量接收返回值
	printf("%d\n", ret);

	n(1);
}

void 函数指针2()
{
	printf("%s\n", "函数指针2");

	//int (*pf)(int, int) = &函数指针_Add;
	int (*pf)(int, int) = 函数指针_Add;// 函数指针_Add === pf

	int ret = pf(3, 5);
	printf("%d\n", ret);

	/*
		这3种写法完全等价
		int ret = (*pf)(3, 5);
		int ret = pf(3, 5);
		int ret = 函数指针_Add(3, 5);

		(*pf)里的*只是摆设，只是看起来更好理解，里面的*再多也是一样，例如(********pf)
	*/

	n(1);
}

int 函数指针数组_Add(int x, int y)
{
	return x + y;
}
int 函数指针数组_Sub(int x, int y)
{
	return x - y;
}
void 函数指针数组()
{
	printf("%s\n", "函数指针数组");

	/*
		把函数的地址存到一个数组中，那这个数组就叫函数指针数组
		函数指针数组，里面存放同类型的函数指针
	*/

	int (*pf1)(int, int) = 函数指针数组_Add;
	int (*pf2)(int, int) = 函数指针数组_Sub;

	int (*pfArr[2])(int, int) = { 函数指针数组_Add, 函数指针数组_Sub };// 放pf1和pf2进去初始化也可也
	/*
		int (*pfArr[2])(int, int);// 函数指针数组
		pfArr首先和[]结合，pfArr[2]，说明是一个数组，2个元素
		对于数组来说除了名字pfArr和[2]之外，剩下的就是元素类型，int (*)(int, int)，类型是函数指针
	*/

	n(1);
}

int 函数指针数组2_计算器_Add(int x, int y)
{
	return x + y;
}
int 函数指针数组2_计算器_Sub(int x, int y)
{
	return x - y;
}
int 函数指针数组2_计算器_Mul(int x, int y)
{
	return x * y;
}
int 函数指针数组2_计算器_Div(int x, int y)
{
	return x / y;
}
void 函数指针数组2_计算器_菜单()
{
	printf("-------- -------- -------- --------\n");
	printf("-------- 1.加         2.减 --------\n");
	printf("-------- 3.乘         4.除 --------\n");
	printf("--------      0.退出       --------\n");
	printf("-------- -------- -------- --------\n");
}
void 函数指针数组2_计算器()
{
	printf("%s\n", "函数指针数组2_计算器");

	/*
		计算器-计算整形变量的加 减 乘 除

		只要增加一个功能就多一个case
		要增加功能就会有很多 冗余的代码，需要简化
	*/
	int 输入 = 0;
	do
	{
		函数指针数组2_计算器_菜单();

		printf("请选择功能>");
		scanf("%d", &输入);

		int x = 0;
		int y = 0;

		int 返回值 = 0;

		switch (输入)
		{
		case 1:
			printf("输入两个操作数>");
			scanf("%d %d", &x, &y);
			返回值 = 函数指针数组2_计算器_Add(x, y);
			printf("计算结果 = %d\n", 返回值);
			break;
		case 2:
			printf("输入两个操作数>");
			scanf("%d %d", &x, &y);
			返回值 = 函数指针数组2_计算器_Sub(x, y);
			printf("计算结果 = %d\n", 返回值);
			break;
		case 3:
			printf("输入两个操作数>");
			scanf("%d %d", &x, &y);
			返回值 = 函数指针数组2_计算器_Mul(x, y);
			printf("计算结果 = %d\n", 返回值);
			break;
		case 4:
			printf("输入两个操作数>");
			scanf("%d %d", &x, &y);
			返回值 = 函数指针数组2_计算器_Div(x, y);
			printf("计算结果 = %d\n", 返回值);
			break;
		case 0:
			printf("退出程序\n");
			break;
		default:
			printf("选择错误\n");
			break;
		}
	} while (输入);

	n(1);
}

void 函数指针数组2_计算器2()
{
	printf("%s\n", "函数指针数组2_计算器2");

	/*
		计算器-计算整形变量的加 减 乘 除

		定义函数指针数组，				int (*pfArr[5])(int, int) = { 0, 函数指针数组2_计算器_Add, 函数指针数组2_计算器_Sub, 函数指针数组2_计算器_Mul, 函数指针数组2_计算器_Div };

		选择1 调用Add函数
		选择2 调用Sub函数
		......

		但是Add函数下标是0，不顺
		将数组改成5个元素，pfArr[5]
		第一个元素放0，放0相当于放了空指针NULL，

		输入是多少就访问下标多少的元素，	(pfArr[输入])
		之后传参，						(pfArr[输入])(x, y)
		调用完成后接收返回值，			返回值 = (pfArr[输入])(x, y)
		之后打印返回值，					printf("计算结果 = %d\n", 返回值);
	*/
	int 输入 = 0;
	do
	{
		函数指针数组2_计算器_菜单();

		int x = 0;
		int y = 0;
		int 返回值 = 0;
		int (*pfArr[5])(int, int) = { 0, 函数指针数组2_计算器_Add, 函数指针数组2_计算器_Sub, 函数指针数组2_计算器_Mul, 函数指针数组2_计算器_Div };

		printf("请选择功能>");
		scanf("%d", &输入);

		if (输入 >= 1 && 输入<= 4)
		{
			printf("输入两个操作数>");
			scanf("%d %d", &x, &y);

			返回值 = (pfArr[输入])(x, y);

			printf("计算结果 = %d\n", 返回值);
		}
		else if(输入 == 0)
		{
			printf("退出成功");
			break;
		}
		else
		{
			printf("选择错误\n");
		}

	} while (输入);

	n(2);
}

void 指向函数指针数组的指针()
{
	printf("%s\n", "指向函数指针数组的指针");

	// 只需了解

	n(1);
}

int 回调函数_计算器_Add(int x, int y)
{
	return x + y;
}
int 回调函数_计算器_Sub(int x, int y)
{
	return x - y;
}
int 回调函数_计算器_Mul(int x, int y)
{
	return x * y;
}
int 回调函数_计算器_Div(int x, int y)
{
	return x / y;
}
void 回调函数_计算器_菜单()
{
	printf("-------- -------- -------- --------\n");
	printf("-------- 1.加         2.减 --------\n");
	printf("-------- 3.乘         4.除 --------\n");
	printf("--------      0.退出       --------\n");
	printf("-------- -------- -------- --------\n");
}
int calc(int (*pf)(int, int))
{
	int x = 0;
	int y = 0;

	printf("输入两个操作数>");
	scanf("%d %d", &x, &y);
	return pf(x, y);
}
void 回调函数_计算器()
{
	printf("%s\n", "回调函数_计算器");

	/*
		计算器-计算整形变量的加 减 乘 除

		回调函数可以理解为参数为函数指针
		回调函数的参数必须设计成指针
		如果calc()参数不设置成指针，这代码就做不成了
		
		这次还是用switch语句
		但是要解决一些问题，有一些代码冗余↓
			printf("输入两个操作数>");
			scanf("%d %d", &x, &y);
			printf("计算结果 = %d\n", 返回值);

		如果将 这些看作一块，做成函数↓
			printf("输入两个操作数>");
			scanf("%d %d", &x, &y);
			返回值 = 回调函数_计算器_Add(x, y);
			printf("计算结果 = %d\n", 返回值);

		但是需要做很多这样的函数，因为里面有些不一样↓
			返回值 = 回调函数_计算器_Add(x, y);
			返回值 = 回调函数_计算器_Sub(x, y);
			......
			返回值 = 回调函数_计算器_Div(x, y);

		设计一个函数 calc()，能实现 加 减 乘 除

		函数名就是函数的地址，将它传进去
			calc(回调函数_计算器_Add);

		然后接收返回值
			返回值 = calc(回调函数_计算器_Add);

		calc()形参
			传过来的是一个函数名，是函数的地址
			需要一个函数指针来接收
				int (*pf)(int, int)

		在calc()函数内创建x，y

		calc()形参 如果pf里接收的是Add函数的地址
		传参给Add函数
			pf(x, y);
		结果再返回
			return pf(x, y);
		......
		calc()形参 如果pf里接收的是Div函数的地址
		传参给Div函数
			pf(x, y);
		结果再返回
			return pf(x, y);
	*/
	int 输入 = 0;
	do
	{
		回调函数_计算器_菜单();

		printf("请选择功能>");
		scanf("%d", &输入);



		int 返回值 = 0;

		switch (输入)
		{
		case 1:
			返回值 = calc(回调函数_计算器_Add);
			printf("计算结果 = %d\n", 返回值);
			break;
		case 2:
			返回值 = calc(回调函数_计算器_Sub);
			printf("计算结果 = %d\n", 返回值);
			break;
		case 3:
			返回值 = calc(回调函数_计算器_Mul);
			printf("计算结果 = %d\n", 返回值);
			break;
		case 4:
			返回值 = calc(回调函数_计算器_Div);
			printf("计算结果 = %d\n", 返回值);
			break;
		case 0:
			printf("退出程序\n");
			break;
		default:
			printf("选择错误\n");
			break;
		}
	} while (输入);

	n(1);
}

int main()
{
	题目1();


	指针数组();

	指针数组2();

	数组指针();

	数组指针2_取地址数组名和数组名();

	数组指针3_数组指针的使用_一维数组();

	数组指针4_数组指针的使用_二维数组();

	一级指针传参();

	二级指针传参();

	函数指针();

	函数指针2();

	函数指针数组();

	//函数指针数组2_计算器();

	//函数指针数组2_计算器2();

	指向函数指针数组的指针();

	回调函数_计算器();

	n(1);


	return 0;
}

void 文档底部()
{
	;
}