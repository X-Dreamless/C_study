

/*

	函数
		本章节主要掌握函数的基本使用和递归
			1.函数是什么
			2.库函数
			3.自定义函数
			4.函数参数
			5.函数调用
			6.函数的嵌套调用和链式访问
			7.函数的声明和定义
			8.函数递归

		C语言中函数的分类
			1.库函数
			2.自定义函数

		C语言常用的库函数
			IO函数(输入输出函数)			printf scanf getchar putchar
			字符串操作函数				strcmp strlen
			字符操作函数					toupper
			内存操作函数					memcpy memcmp memset
			时间/日期函数				time
			数学函数						sqrt pow
			其他库函数



		函数返回类型	 ----------------函数的参数------------------
		 ↓			↓                                           ↓
		char *strcpy(char *strDestination, const char *strSource);
				↑
			  函数名


		函数的参数
			函数调用传输的参数 叫 实际参数
			函数定义接收的参数 叫 形式参数

			实参
				真实传给函数的参数，叫实际参数。实参可以是：常量 变量 表达式 函数等。
				无论实参是何种类型的量，在进行函数调用时，它们都必须有确定的值，以便把他们这些值传送给形式参数

			形参
				形式参数是指函数名后括号中的变量 因为形式参数只有在函数被调用的过程中才实例化(分配内存单元)，
				所以叫形式参数。形式参数当函数调用完成之后就自动销毁。因此形式参数只在函数中有效


		函数的调用
			传值调用
				函数的形参和实参分别占有不同内存块，对形参的修改不会影响实参

			传址调用
				传址调用是吧函数外部创建变量的内存地址传递给函数参数的一种调用函数的方式。
				这种传参方式可以让函数和函数外边的变量建立起正真的联系，也就是函数内部可以直接操作函数外部的变量。



		函数的嵌套调用和链式访问
			嵌套调用
				函数不能嵌套定义 例如:
					int test1()
					{
						int test2()
						{

						}
					}

				函数可以嵌套调用 例如
					int test1()
					{
						test2();
					}

					int test3()
					{
						test1();
					}

			链式访问
				把一个函数的返回值作为另外一个函数的参数




		函数的声明和定义
			函数声明
				1.告诉编译器有一个函数叫什么，参数是什么，返回类型是什么。具体无关紧要
				2.函数的声明一般出现在函数的使用之前。要满足先声明后使用。
				3.函数的声明一般要放在头文件中

			函数定义
				函数的定义是指函数的具体实现，交待函数的功能实现



		函数递归
			什么是递归？(函数自己调用自己)
				程序调用自身的编程技巧称为递归(recursion)。递归作为一种算法在程序设计语言中广泛应用。
				一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的
				问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可以描述
				出解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的主要思考方式在于：大事化小

			递归的两个必要条件(必要 不充足)
				1.存在限制条件，当满足这个限制条件的时候，递归便不在继续
				2.每次递归调用之后越来越接近这个限制条件

			每次调用函数都会在栈区开辟一个新空间
			写递归代码的时候
				1.不能死递归，要有跳出条件，每次递归要逼近跳出条件
				2.递归层次不能太深，不然也会栈溢出


		https://stackoverflow.com/
		程序员的知乎
*/

#define _CRT_SECURE_NO_WARNINGS 1

#include <stdio.h>

#include <string.h>


// 练习2
// 编写函数不允许创建临时变量，求字符串长度
// 
// 模拟实现一个strlen函数
//int 字符串长度(char*数组)
//{
//	int 个数 = 0;
//	while (*数组 != '\0')
//	{
//		个数++;
//		数组++;
//	}
//	return 个数;
//}
// 递归
// 字符串长度("abc")
// 1 + 字符串长度("bc")
// 1 + 1 +字符串长度("c")
// 1 + 1 + 1 + 字符串长度("")
// 1 + 1 + 1 + 0 = 3
// 地址+1表示到下一个元素。
// 数组++ 是先使用再运算，这里是要先运算再使用
// ++数组 也不行，因为这是指针，自增运算改变了指针的位置，会改变实参
int 字符串长度(char* 数组)
{
	if (*数组 != '\0')
	{
		return 1 + 字符串长度(数组 + 1);
	}
	else
	{
		return 0;
	}
}













// 递归与迭代
// 练习3
// 求n的阶乘(不考虑溢出)
// n!
// 1*2*3*...*n
// 
// 阶乘数学公式
//		   --- n <= 1 , 1
//		   |
// Fac(n) -|
//		   |
//		   --- n > 1  , n * Fac(n - 1)
int Fac(int n)
{
	if (n <= 1)
	{
		return 1;
	}
	else
	{
		return n * Fac(n - 1);
	}
}

















// 练习4
// 求第n个斐波那契数(不考虑溢出)
// 前两个数之和是斐波那契数
// 1 1 2 3 5 8 13 21 34 55
// 
// 公式
//		   --- n <= 2 , 1
//		   |
// Fib(n) -|
//		   |
//		   --- n > 2  , Fib(n - 1) + Fib(n - 2)
// 效率太低 - 重复大量计算
//													50
//							49												48
//				48						47						47						46
//		47				46		46				45		46				45		45				44
//
//
// 递归可以求解 但是效率低
//int Fib(int n2)
//{
//	if (n2 <= 2)
//	{
//		return 1;
//	}
//	else
//	{
//		return Fib(n2 - 1) + Fib(n2 - 2);
//	}
//}
// 
// 循环
// 1	1	2	3	5	8	13	21	34	55
// a	b	c
//		a	b	c
//			a	b	c
// 
int Fib(int n2)
{
	int a = 1;
	int b = 1;
	int c = 1;
	while (n2 > 2)
	{
		c = a + b;
		a = b;
		b = c;
		n2--;
	}
	return c;
}








int main()
{
	// 练习2
	// 编写函数不允许创建临时变量，求字符串长度
	// 
	// 模拟实现一个strlen函数
	// ['a'] ['b'] ['c'] ['\0']
	char arr[] = "bit";
	printf("%d\n", 字符串长度(arr));








	// 递归与迭代
	// 练习3
	// 求n的阶乘(不考虑溢出)
	// n!
	// 1*2*3*...*n
	// 
	// 阶乘数学公式
	//		   --- n <= 1 , 1
	//		   |
	// Fac(n) -|
	//		   |
	//		   --- n > 1  , n * Fac(n - 1)
	//int n = 0;
	//int i = 0;
	//int ret = 1;
	//printf("阶乘>")
	//scanf("%d", &n);
	//// 循环也可也称谓迭代
	//for (i = 1; i <= n; i++)
	//{
	//	ret = ret * i;
	//}
	//printf("%d\n", ret);

	int n = 0;
	printf("阶乘>");
	scanf("%d", &n);
	int ret = Fac(n);
	printf("%d\n", ret);








	// 练习4
	// 求第n个斐波那契数(不考虑溢出)
	// 前两个数之和是斐波那契数
	// 1 1 2 3 5 8 13 21 34 55
	// 
	// 公式
	//		   --- n <= 2 , 1
	//		   |
	// Fib(n) -|
	//		   |
	//		   --- n > 2  , Fib(n - 1) + Fib(n - 2)
	int n2 = 0;
	printf("斐波那契>");
	scanf("%d", &n2);
	int ret2 = Fib(n2);
	printf("%d\n", ret2);







	return 0;
}