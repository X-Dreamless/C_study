/*
	操作符详解
		操作符和表达式
			1.各种操作符的介绍
			2.表达式求值

			操作符
				分类
					算数操作符
					移位操作符
					位操作符
					赋值操作符
					单目操作符
					关系操作符
					逻辑操作符
					条件操作符
					逗号表达式
					下标引用、函数调用和结构成员

					------------------------------------------

					算数操作符
						+
						-
						*
						/
						%
						
						1.除了%操作符之外，其他的几个操作符可以作用于整数和浮点数
						2.对于/操作符如果两个操作数都为整数，执行整数除法。而只要有浮点数执行的就是浮点数除法。
						3.%操作符的两个操作数必须为整数。返回的是整除之后的余数

					------------------------------------------

					移位操作符
						<< 左移
						>> 右移

						移位操作不会改变本身
							int c = 2;
							c << 1;
							printf("c = %d\n", c);// 2

						左移操作符 移位规则
							左边抛弃、右边补0

								int c = 2;
								// 把c的二进制位向左移动一位
								int c2 = c << 1;
								printf("c2 = %d\n", c2);

								// 整形变量 4字节 = 32比特位
								// 十进制2 = 二进制 [00000000 00000000 00000000 00000010]
								// 左移	0[0000000 00000000 00000000 000000100]
								//	    ↑									↑
								//	 溢出丢弃							   补0
								// 现在1来到了第三位，是2的2次方 = 4
								//

						右移操作符 移位规则
							1.算术右移
								右边丢弃，左边补原符号位

							2.逻辑右移
								右边丢弃，左边补0，不管正负数


							c6验证是 算术右移 还是 逻辑右移
								int c3 = 10;
								// 把c的二进制位向右移动一位 - 当前使用的是 算数右移
								int c4 = c3 >> 1;
								printf("c4 = %d\n", c4);
								// 十进制2 = 二进制 [00000000 00000000 00000000 00000010]
								// 右移	[000000000 00000000 00000000 0000101]0
								//		 ↑									 ↑
								//	    补0							      溢出丢弃

								// 用负数测试编译器是 算术右移 还是 逻辑右移 - 当前使用的是 算数右移
								int c5 = -1;
								int c6 = c5 >> 1;
								printf("c6 = %d\n", c6);
								// 负数 -1 存放在内存中 存放的是二进制的补码
								//
								// 整数的二进制表示形式：有3种
								//	原码：直接根据数值写出的二进制序列就是原码
								//	反码：原码的符号位不变，其他位按位取反就是反码
								//	补码：反码+1，就是补码
								//
								// -1原码：	[10000000 00000000 00000000 00000001]
								//			 ↑
								//		 这个1表示负数 符号位
								//
								// -1反码：	[11111111 11111111 11111111 11111110]
								//
								// -1补码：	[11111111 11111111 11111111 11111111]
								//
								// -1右移：	[ 1111111 11111111 11111111 11111111]1
								//			 ↑
								//		 算数补1原符号位，逻辑补0。补0就变正数

								原码 反码 补码 这个算法只针对负数，正整数的原码反码补码相同

					------------------------------------------

					位操作符
						& 按位与
						| 按位或
						^ 按位异或

						注：他们的操作数必须是整数

						int d = 3;	// 00000000 00000000 00000000 00000011
						int d2 = 5;	// 00000000 00000000 00000000 00000101
						// & - 按(二进制)位与 - 计算的位置相同是1，不同是0
						int d3 = d & d2; // 00000000 00000000 00000000 00000001
						printf("d3 = %d\n", d3);
						// 00000000 00000000 00000000 00000011 d
						// 00000000 00000000 00000000 00000101 d2
						// 00000000 00000000 00000000 00000001 d3计算结果

						// 按(二进制)位或 - 有1则1，同时为0则0
						int d4 = d | d2;
						printf("d4 = %d\n", d4);
						// 00000000 00000000 00000000 00000011 d
						// 00000000 00000000 00000000 00000101 d2
						// 00000000 00000000 00000000 00000111 d4计算结果

						// 按(二进制)位异或 - 对应的二进制位异或 - 相同为0，相异为1
						int d5 = d ^ d2;
						printf("d5 = %d\n", d5);
						// 00000000 00000000 00000000 00000011 d
						// 00000000 00000000 00000000 00000101 d2
						// 00000000 00000000 00000000 00000110 d5计算结果

*/

#include "define.h"

int main()
{
	// 打印不是小数，源头问题是6/5就是1，两端至少是一个浮点数即可
	float a = 6 / 5;
	printf("a = %f\n", a);

	float a2 = 6.0 / 5;
	printf("a2 = %f\n", a2);

	// 直接写出两端浮点数，编译器默认是double类型的，放到float里可能会丢失精度
	// 可以6.0f / 5.0f
	float a3 = 6.0 / 5.0;
	printf("a3 = %f\n", a3);










	int b = 7 % 3;//余数
	printf("b = %d\n", b);










	int c = 2;
	// 把c的二进制位向左移动一位
	int c2 = c << 1;
	printf("c2 = %d\n", c2);

	// 整形变量 4字节 = 32比特位
	// 十进制2 = 二进制 [00000000 00000000 00000000 00000010]
	// 左移	0[0000000 00000000 00000000 000000100]
	//	    ↑									↑
	//	 溢出丢弃							   补0
	// 现在1来到了第三位，是2的2次方 = 4
	// 

	int c3 = 10;
	// 把c的二进制位向右移动一位 - 当前使用的是 算数右移
	int c4 = c3 >> 1;
	printf("c4 = %d\n", c4);
	// 十进制2 = 二进制 [00000000 00000000 00000000 00000010]
	// 右移	[000000000 00000000 00000000 0000101]0
	//		 ↑									 ↑
	//	    补0							      溢出丢弃

	// 用负数测试编译器是 算术右移 还是 逻辑右移
	int c5 = -1;
	int c6 = c5 >> 1;
	printf("c6 = %d\n", c6);
	// 负数 -1 存放在内存中 存放的是二进制的补码
	// 
	// 整数的二进制表示形式：有3种
	//	原码：直接根据数值写出的二进制序列就是原码
	//	反码：原码的符号位不变，其他位按位取反就是反码
	//	补码：反码+1，就是补码
	//	
	// -1原码：	[10000000 00000000 00000000 00000001]
	//			 ↑
	//		 这个1表示负数 符号位
	// 
	// -1反码：	[11111111 11111111 11111111 11111110]
	// 
	// -1补码：	[11111111 11111111 11111111 11111111]
	// 
	// -1右移：	[ 1111111 11111111 11111111 11111111]1
	//			 ↑
	//		 算数补1原符号位，逻辑补0。补0就变正数
	// 










	int d = 3;	// 00000000 00000000 00000000 00000011
	int d2 = 5;	// 00000000 00000000 00000000 00000101
	// & - 按(二进制)位与 - 计算的位置相同是1，不同是0
	int d3 = d & d2; // 00000000 00000000 00000000 00000001
	printf("d3 = %d\n", d3);
	// 00000000 00000000 00000000 00000011 d
	// 00000000 00000000 00000000 00000101 d2
	// 00000000 00000000 00000000 00000001 d3计算结果

	// 按(二进制)位或 - 有1则1，同时为0则0
	int d4 = d | d2;
	printf("d4 = %d\n", d4);
	// 00000000 00000000 00000000 00000011 d
	// 00000000 00000000 00000000 00000101 d2
	// 00000000 00000000 00000000 00000111 d4计算结果

	// 按(二进制)位异或 - 对应的二进制位异或 - 相同为0，相异为1
	int d5 = d ^ d2;
	printf("d5 = %d\n", d5);
	// 00000000 00000000 00000000 00000011 d
	// 00000000 00000000 00000000 00000101 d2
	// 00000000 00000000 00000000 00000110 d5计算结果
	
	// 交换两个变量的值，不能使用第三个变量
	int d6 = 3;
	int d7 = 5;
	printf("--------\n");
	printf("d6 = %d，d7 = %d\n", d6, d7);
	//// 有缺陷 数值太大会溢出
	//d6 = d6 + d7;
	//d7 = d6 - d7;
	//d6 = d6 - d7;

	// 异或
	d6 = d6 ^ d7;
	d7 = d6 ^ d7;
	d6 = d6 ^ d7;
	//					初始值										计算过程
	//												d6 = d6 ^ d7;	d7 = d6 ^ d7;	d6 = d6 ^ d7;
	// 00000000 00000000 00000000 00000011 d6		110				110				101
	// 00000000 00000000 00000000 00000101 d7		101				011				011
	printf("d6 = %d，d7 = %d\n", d6, d7);
	printf("--------\n");

	// 两次异或就等于本身
	// a^b^b=a
	// 
	// 和本身异或等于0
	// a^a=0
	// 0^a=a
	// 




	return 0;
}