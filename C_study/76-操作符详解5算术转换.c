/*
	隐式类型转换
	算术转换
		如果某个操作符的各个操作数属于不同的类型，那么除非其中一个操作数的转换为另一个操作数的类型，否则操作就无法进行。

		寻常算术转换 - 向上转换
			long double
			double
			float
			unsigned long int
			long int
			unsigned int
			int

			如果某个操作数的类型在上面这个列表中排名较低，那么首先要转换为另外一个操作数的类型后执行运算。

			如果int和float计算 int会转换成float
			向字节长的，精度高的转换

			

	操作符的属性
		复杂表达式的求值有三个影响的因素
			1.操作符的优先级
			2.操作符的结合性
			3.是否控制求值顺序

		两个相邻的操作符先执行哪个 取决于他们的优先级。如果两者的优先级相同，取决于他们的结合性。

		一些问题表达式
			// 表达式的求值部分由操作符的优先级决定
			// 表达式1
				a*b + c*d + e*f;
				代码1在计算的时候，由于*比+的优先级高，只能保证*的计算是比+早，但是优先级并不能决定第三个*比第一个+早执行
				所以表达式的计算机顺序就可能是
				a*b
				c*d
				a*b + c*d
				e*f
				a*b + c*d + e*f
				或
				a*b
				c*d
				e*f
				a*b + c*d
				a*b + c*d + e*f
			
				abcdef可能不只是变量，可能是表达式



			// 表达式2
				如果c = 3
				c + --c;
				3 +   2 = 5
				2 +   2 = 4
				--优先级大于+
				同上，操作符的优先级只能决定自减--的运算在+的运算的前面，但是我们并没有办法得知，
				+操作符的左操作数的获取在右操作数之前还是之后求值，所以结果是不可预测的，是有歧义的


			// 代码3 - 非法表达式
			// 来自《C和指针》 这本书的作者在各种编译器里测试这段代码结果各不同
				int i = 10;
				i = i-- - --i * (i = -3) * i++ + ++i;
				printf("i = %d\n", i);



			// 代码4
				int fun()
				{
					static int count = 1;
					return ++count;
				}
				int main()
				{
					int answer;
					answer = fun() - fun() * fun();
					printf("%d\n", answer);
					return 0;
				}
			虽然在大多数的编译器上求得结果都是相同
			但是上述代码answer = fun() - fun() * fun();中我们只能通过操作符的优先级得知：先算乘法，再算减法
			函数的调用先后顺序无法通过操作符的优先级决定



			// 代码5
				int i = 1;
				int ret = (++i) + (++i) + (++i);
				printf("%d\n", ret);
			// vs运行结果    12 先(++i)(++i)(++i) 再(++i) + (++i) + (++i)
			// Linux运行结果 10 先(++i)(++i) 再 (++i) + (++i) ......
			简单看一下汇编代码就可以分析清楚
			这段代码中的第一个+在执行的时候，第三个++是否执行，这个是不确定的，因为依靠操作符的优先级
			和结合性是无法决定第一个+和第三个前置++的先后顺序


			总结：我们写出的 表达式 如果不能通过 操作符 的属性确定唯一的计算路径，那这个表达式就是存在问题的
*/

#include "define.h"

int main()
{

	return 0;
}