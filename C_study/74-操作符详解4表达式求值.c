/*
	表达式求值
		表达式求值的顺序一部分是由操作符的优先级和结合性决定。
		同样，有些表达式的操作数在求值的过程中可能需要转换为其他类型


	隐式类型转换
		C的整形算数运算总是至少以缺省整形类型的精度来进行的
		为了获得这个精度，表达式中的字符和短整形操作数在使用之前被转换为普通整形，这种转换称为 整形提升

		整形提升的意义：
			表达式的整形运算要在CPU的相应运算器件内执行，CPU内整形运算器(ALU)的操作数的字节长度一般就是int的字节长度
			，同时也是CPU的通用寄存器的长度。

			因此，即使两个char类型的相加，在CPU执行时实际上也要先转换为CPU内整形操作数的标准长度。

			通用CPU(general-purpose CPU)是难以直接实现两个8比特字节直接相加运算(虽然机器指令中可能有这种字节相加指令)。
			所以，表达式中各种长度可能小于int长度的整形值，都必须先转换为int或unsigned int，然后才能送入CPU去执行运算。


			// 实例1
			char a,b,c;
			......
			a = b + c;
			b和c的值被提升为普通整形，然后再执行加法运算。
			加法运算完成之后，结果将被截断，然后再存储于a中。


		如何进行整体提升
			整形提升是按照变量的数据类型的符号位来提升的


		长度小于int类型运算才会整形提升
		比int大就不用提升

*/

#include "define.h"

int main()
{
	//															  符号位
	//															    ↓
	char a = 3;		// 00000000 00000000 00000000 00000011 截断后	00000011
	char b = 127;	// 00000000 00000000 00000000 01111111 截断后	01111111
	char c = a + b;	// 
	// 提升a 看a的类型 char 有符号char 00000011高位的是符号位 整形提升补的是符号位 00000000 00000000 00000000 00000011
	// 提升b 看b的类型 char 有符号char 01111111高位的是符号位 整形提升补的是符号位 00000000 00000000 00000000 01111111
	// 
	// 因为char为有符号的char 所以整形提升的时候，高位补充符号位
	// 无符号整形提升，高位补0
	// 
	// 相加
	// 00000000 00000000 00000000 00000011
	// 00000000 00000000 00000000 01111111
	// 00000000 00000000 00000000 10000010 截断后 c = 10000010
	// 
	// 
	// 
	// 


	// 发现a和b都是char类型，都没有达到一个int的大小
	// 这里就会发生整形提升

	printf("%d\n", c);// -126
	// c 还是char类型 为了打印一个整形 发生整形提升
	// 11111111 11111111 11111111 10000010 - 补码
	// 负数内存中存的是补码 打印出来要求原码
	// 
	// 减一
	// 11111111 11111111 11111111 10000001 - 反码
	// 
	// 取反
	// 10000000 00000000 00000000 01111110- 原码
	// 
	// 
	// 



	// 整形提升
	char d = 0xb6;
	short e = 0xb600;
	int f = 0xb6000000;

	if (d == 0xb6)
		printf("d");
	if(e == 0xb600)
		printf("e");
	if(f == 0xb6000000)
		printf("f\n");



	char g = 1;
	printf("%u\n", sizeof(g));	// 1	
	printf("%u\n", sizeof(+g));	// 4 表达式参与运算 整形提升
	printf("%u\n", sizeof(-g));	// 4 表达式参与运算 整形提升
	// %u打印无符号整形
	// sizeof看的是结果类型

	int h = 3;
	int i = 5;
	h + i;
	// 表达式都有两个属性
	// 值属性 计算完成后有值	  这里值是	8
	// 类型属性 计算结果有类型 这里类型是	int
	// 
	// 
	//


	return 0;
}