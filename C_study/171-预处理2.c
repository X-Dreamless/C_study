/*
	程序环境和预处理

		本章重点
			1. 程序的翻译环境
			2. 程序的执行环境
			3. 详解：C语言程序的编译+链接
			4. 预定义符号介绍
			5. 预处理指令 #define
			6. 宏和函数的对比
			7. 预处理操作符#和##的介绍
			8. 命令定义
			9. 预处理指令 #include
			10 预处理指令 #undef
			11 条件编译

		――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
		----------------------------------------------------------------

		1. 程序的翻译环境

			在ANSI C的任何一种实现中，存在两个不同的环境
				第1种是翻译环境，在这个环境中源代码被转换为可执行的机器指令。
				第2种是执行环境，它用于实际执行代码。

		----------------------------------------------------------------

		2. 程序的执行环境

			在ANSI C的任何一种实现中，存在两个不同的环境
				第1种是翻译环境，在这个环境中源代码被转换为可执行的机器指令。
				第2种是执行环境，它用于实际执行代码。

				test.c →翻译环境→ test.exe →运行环境→ 运行结果
						VS2022

		----------------------------------------------------------------

		3. 详解：C语言程序的编译+链接

			3.1 翻译环境

				程序编译过程

				源文件 → 编译器 → [    ]目标文件 →
				                                ↓
				源文件 → 编译器 → [    ]目标文件 →
				                                ↓
				源文件 → 编译器 → [    ]目标文件 →
				                                ↓
				链接库 → 链接器←←←←←←←←←←←←←←←←←←←
				           ↓
				       可执行程序

				每个 源文件 都是单独处理的

				.obj 目标文件
				.lib 静态库

				编译：
					组成一个程序的每个源文件（.c文件）通过编译过程分别转换成目标代码（.obj文件）(object code)。
				链接：
					每个目标文件由链接器（linker）捆绑在一起，形成一个单一而完整的可执行程序（.exe文件）。

					链接器同时也会引入标准C函数库中任何被该程序所用到的函数，
					而且它可以搜索程序员个人的程序库，将其需要的函数也链接到程序中。


				test.c
				↓
				编译环境(VS2022集成开发环境)
					编译
						编译器cl.exe
							预编译(预处理)
								(*.i)
								(文本操作)
								#include 头文件的包含 (将源文件中以”include”格式包含的文件复制到编译的源文件中)
								#define 定义的符号和宏的替换 (用实际值替换用“#define”定义的字符串。)
								根据“#if”后面的条件决定需要编译的代码。
								删除注释
								......
								(gcc test.c -E)(gcc test.c -E > test.i)
							编译
								(*.s)
								把 C语言代码 转换成 汇编代码
								语法分析
								词法分析
								语义分析
								符号汇总
								(gcc test.i -S)
							汇编
								(*.o)(*.obj)
								(test.o 是elf格式的文件)(test.o 划分成了一个一个的段)(每一个段里存放的数据不同)(readelf命令，一般用于查看ELF格式的文件信息)
								把 汇编代码 转换成 机器指令(二进制指令)
								形成符号表
								(gcc test.s -c)
								(readelf test.o -s)
					链接
						链接器link.exe
							(*.out)(*.exe)
							(.out和.exe也是elf格式)
							把多个 目标文件 和 链接库 进行链接
							合并段表(相同段的数据合并)
							符号表的合并和符号表的重定位
				↓
				test.exe
				↓
				运行环境
				↓
				运行结果


			3.2 编译本身也分为几个阶段

				----------------------------------------------------------------------------------------------------------------------
				|    test.c  |  预编译阶段(*.i)  |  编译(*.s)  |  汇编(生成可重定目标文件*.o)     |  链接                              |
				|            |  预处理指令       |  语法分析   |  形成符号表                      |                                    |
				|            |                   |  词法分析   |  汇编指令->二进制指令--->test.o  |  1. 合并段表                       |
				|            |                   |  语义分析   |  汇编指令->二进制指令--->sum.o   |  2. 符号表的合并和符号表的重定位    |
				|    sum .c  |                   |  符号汇总   |                                 |                                    |
				|--------------------------------------------------------------------------------------------------------------------|
				|    隔离编译，一起链接                                                                                               |
				----------------------------------------------------------------------------------------------------------------------

				合并段表
					[ ] →← [ ]
					[ ] →← [ ]
					[ ] →← [ ]
					[ ] →← [ ]
					[ ] →← [ ]

				形成符号表
					(test.c里Add函数只是声明，没有确切地址)
					test.c    [Add] [0x0000]
					          [main][0x1004]

					sum.c     [Add] [0x1008]

				符号表的合并和符号表的重定位
					(筛选有效地址的符号)
					test.c    [Add] [0x0000] -
					          [main][0x1004]  |
					                          | → [Add] [0x1008]
					sum.c     [Add] [0x1008] -    [main][0x1004]
					(链接好的可执行程序，调用函数，通过地址就能找到函数)


			3.3 运行环境
				
				程序执行的过程

					1. 程序必须载入内存中。在有操作系统的环境中：一般这个由操作系统完成。
					   在独立的环境中，程序的载入必须由手工安排，也可能是通过可执行代码置入只读内存来完成。

					2. 程序的执行便开始。接着便调用main函数。

					3. 开始执行程序代码。这个时候程序将使用一个运行时堆栈（stack）(即前面学的函数栈帧)，存储函数的局部变量和返回地址。
					   程序同时也可以使用静态（static）内存，存储于静态内存中的变量在程序的整个执行过程一直保留他们的值。

					4. 终止程序。正常终止main函数；也有可能是意外终止。

		----------------------------------------------------------------
		4. 预定义符号介绍
		----------------------------------------------------------------
		5. 预处理指令 #define
		----------------------------------------------------------------
		6. 宏和函数的对比
		----------------------------------------------------------------
		7. 预处理操作符#和##的介绍
		----------------------------------------------------------------
		8. 命令定义
		----------------------------------------------------------------
		9. 预处理指令 #include
		----------------------------------------------------------------
		10 预处理指令 #undef
		----------------------------------------------------------------
		11 条件编译
		----------------------------------------------------------------
		――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
*/
/*
		――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

		资料推荐

			《程序员的自我修养》

			简明 VIM 练级攻略
			https://coolshell.cn/articles/5426.html

			给程序员的VIM速查卡
			https://coolshell.cn/articles/5479.html
*/
