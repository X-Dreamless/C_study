/*
	深度剖析数据在内存中的存储

											// release版本没有死循环 release版本做了优化
											int i = 0;
											int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
											for (i = 0; i <= 12; i++)
											{
												arr[i] = 0;
												printf("hehe\n");
											}

											// debug版本和release版本地址对比
											int i = 0;
											int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
											//								debug		release
											printf("%p\n", &i);		//		地址大	|	地址小
											printf("%p\n", &arr[9]);//		地址小	|	地址大

											release 称为发布版本，它往往是进行了各种优化，使得程序在代码大小和运行速度上都是最优的，以便用户很好地使用

		本章重点
			1.数据类型详细介绍
			2.整形在内存中的存储：原码、反码、补码
			3.大小端字节序介绍及判断
			4.浮点型在内存中的存储解析

		-------- -------- -------- -------- --------

		1.数据类型详细介绍
			前面我们已经学习了基本的内置类型：
				char		字符数据类型
				short		短整形
				int			整形
				long		长整形
				long long	更长的整形
				float		单精度浮点数
				double		双精度浮点数
				// C语言有没有字符串类型？
			以及他们所占存储空间的大小

			类型的意义：
				1.使用这个类型开辟内存空间的大小(大小决定了使用范围)
				2.如何看待内存空间的视角

			类型的基本归类：

				整形家族
					char
						unsigned char
						signed char

					short
						unsigned short [int]
						signed short [int]

					int
						unsigned int
						signed int

					long
						unsigned long [int]
						signed long [int]

				浮点数家族
					float
					double

				构造类型(自定义类型)
					数组类型
					结构体类型 struct
					枚举类型 enum
					联合类型 union

				指针类型
					int* pi;
					char* pc;
					float* pf;
					void* pv;

				空类型
					void 表示空类型(无类型)
					通常应用于函数的返回类型、函数的参数、指针类型。

		-------- -------- -------- -------- --------

		2.整形在内存中的存储：原码、反码、补码

			数据在内存中以二进制的形式存储
			对于整数来说 整数二进制有3种表示形式：原码、反码、补码
			正整数：原码、反码、补码相同
			负整数：原码、反码、补码要进行计算
			整数在内存中存储的是补码

			为什么整数在内存中存储的是补码？

				在计算机系统中，数值(整数)一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理；
				同时，加法和减法也可也统一处理(CPU只有加法器)此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路

				因为0和-0是一样的，但是在原码中的0和-0最高位就不同，所以科学家就提出了反码，但是反码也表示不出0和-0相同，
				而反码再加1就可以表示0和-0相同，所以就产生了补码

				CPU没有减法器 计算以下
					1 + 1
					1 + (-1)
				用原码计算 结果不正确
					00000000 00000000 00000000 00000001 = 1
					+
					10000000 00000000 00000000 00000001 = -1
					=
					10000000 00000000 00000000 00000010 = -2

				用补码计算
					00000000 00000000 00000000 00000001 = 1
					+
					11111111 11111111 11111111 11111111 = -1
					=
				   100000000 00000000 00000000 00000000 = 0
				   ↑
				   多出的位 丢弃

			原码：按照数据的数值直接写出的二进制序列
			反码：原码的符号位不变 其他位按位取反
			补码：反码+1

			补码 取反 +1 就是原码

		-------- -------- -------- -------- --------

		3.大小端字节序介绍及判断

			大小端介绍
				大端(存储)模式，是指数据的 低位 保存在内存的 高地址 中，而数据的 高位 保存在内存的 低地址 中
				小端(存储)模式，是指数据的 低位 保存在内存的 低地址 中，而数据的 高位 保存在内存的 高地址 中


				// 大端字节序和小端字节序
				int c = 0x11223344;
						  ↑      ↑
						 高      低

				以下两种存放方式，怎么存放的就怎么拿出来
									内存
						--------------------------------
						|		11 22 33 44			   |	正着存 大端字节序
						--------------------------------
				低地址										高地址
						--------------------------------
						|		44 33 22 11			   |	倒着存 小端字节序
						--------------------------------


				关于正着存还是倒着存是根据操作系统决定的
				在windows系统下 内存的地址都是从0开始往后排的但是数据本身就有高地址和低地址之分，
				所以数据的存储数据的 高位地址 就在内存的 高地址上面，数据的 低地址 就在 低地址

			为什么有大端和小端
				为什么有大端和小端模式之分呢？这是因为在计算机系统中，我们是以字节为单位的，
				每个地址单元对应着一个字节，一个字节8bit。但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型
				(要看具体的编译器)，另外，对于位数大的8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，
				那么必然存在着一个如果将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。

				例如一个16bit的short型x，在内存中的地址为0x0010，x的值为0x1122，那么0x11为高字节，0x22为低字节。
				我们常用的x86结构是小端模式，而KETL C51则为大端模式。很多的ARM，DSP都为小端模式。
				有些ARM处理器还可以由硬件来选择是大端模式还是小端模式

				因为数据存在内存中可能占的不止一个字节 也有可能是2个 8个...。这就会有存放顺序的问题

		-------- -------- -------- -------- --------
		-------- -------- -------- -------- --------
		补充
			char C语言标准没有规定是signed char还是unsigned char，取决于编译器。大部分编译器都是signed char
			int 是signed int
			short 是signed short

			char类型变量的取值范围
				char占1字节 = 8bit

						  内存
				char	00000000	8个比特位里面要存放数据的话 可能存放的是8个0 到 8个1 的可能性
						00000001
						01111111	= 127
						...
						10000000	= -128 这样的二进制数字不能进行 -1 取反 ，内存里发现这样的二进制序列 会被直接解析成-128
						11111110
						11111111	反码11111110 原码10000001 = -1

				有符号char的取值范围-128~127
		-------- -------- -------- -------- --------



*/

#include "define.h"

int 大小端()
{
	// 设计一个小程序来判断当前机器的字节序
	int a = 1;

	// 只拿第一个字节
	char* p = (char*)&a;// 强制类型转换 &a取出的是一个整形的地址
	if (*p == 1)
	{
		return 1;
	}
	else
	{
		return 0;
	}
}

// 简化
int 大小端2()
{
	
	int a = 1;
	char* p = (char*)&a;
	return *p;// 返回1小端，返回0大端
}











// 题目
// 下面程序输出什么？
void 题目1()
{
	// -1是整数，整形-1放到char类型a变量里，内存里是补码11111111 11111111 11111111 11111111，截断11111111
	char a = -1;

	// 截断11111111
	signed char b = -1;

	// 截断11111111，无符号
	unsigned char c = -1;

	// %d打印，整形提升，看的是原符号位
	// a 补码11111111 11111111 11111111 11111111 打印的是原码10000000 00000000 00000000 00000001
	// b 和 a 一样
	// c 无符号整形提升高位补0，补码00000000 00000000 00000000 11111111，原码00000000 00000000 00000000 11111111，正数原反补相同
	printf("a = %d,b = %d,c = %d\n", a, b, c);// a = -1,b = -1,c = 255
}

// 下面程序输出什么？
void 题目2()
{
	// -128 原码10000000 00000000 00000000 10000000
	//	    反码11111111 11111111 11111111 01111111
	//		补码11111111 11111111 11111111 10000000
	//		截断                           10000000
	//整形提升	11111111 11111111 11111111 10000000 有符号 高位补符号位
	char a = -128;

	// 无符号 11111111 11111111 11111111 10000000
	printf("%u\n", a);// 4294967168
}

// 下面程序输出什么？
void 题目3()
{
	// 128 原反补相同	00000000 00000000 00000000 10000000
	//	   截断									   10000000
	//	   整型提升		11111111 11111111 11111111 10000000 有符号 高位补符号位 整形提升是由提升对象的符号位决定的
	char a = 128;
	printf("%u\n", a);// 4294967168
}

// 下面程序输出什么？
void 题目4()
{
	// i 原码10000000 00000000 00000000 00010100
	//   反码11111111 11111111 11111111 11101011
	//   补码11111111 11111111 11111111 11101100
	int i = -20;

	// j 原码10000000 00000000 00000000 00001010 正数原反补相同
	unsigned int j = 10;

	// i 补码11111111 11111111 11111111 11101100
	// +
	// j 补码10000000 00000000 00000000 00001010
	// = 
	// 补码11111111 11111111 11111111 11110110
	// = 
	// 反码11111111 11111111 11111111 11110101
	// =
	// 原码10000000 00000000 00000000 00001010 = -10
	//
	printf("%d\n", i + j);// -10
}







int main()
{
	int ret = 大小端2();
	if (ret == 1)
	{
		printf("小端\n");
	}
	else
	{
		printf("大端\n");
	}










	题目1();
	
	题目2();

	题目3();

	题目4();


	





	return 0;
}