/*
	程序环境和预处理

		本章重点
			1. 程序的翻译环境
			2. 程序的执行环境
			3. 详解：C语言程序的编译+链接
			4. 预定义符号介绍
			5. 预处理指令 #define
			6. 宏和函数的对比
			7. 预处理操作符#和##的介绍
			8. 命令定义
			9. 预处理指令 #include
			10 预处理指令 #undef
			11 条件编译

		――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
		----------------------------------------------------------------

		1. 程序的翻译环境

			在ANSI C的任何一种实现中，存在两个不同的环境
				第1种是翻译环境，在这个环境中源代码被转换为可执行的机器指令。
				第2种是执行环境，它用于实际执行代码。

		----------------------------------------------------------------

		2. 程序的执行环境

			在ANSI C的任何一种实现中，存在两个不同的环境
				第1种是翻译环境，在这个环境中源代码被转换为可执行的机器指令。
				第2种是执行环境，它用于实际执行代码。

				test.c →翻译环境→ test.exe →运行环境→ 运行结果
						VS2022

		----------------------------------------------------------------

		3. 详解：C语言程序的编译+链接

			3.1 翻译环境

				程序编译过程

				源文件 → 编译器 → [    ]目标文件 →
				                                ↓
				源文件 → 编译器 → [    ]目标文件 →
				                                ↓
				源文件 → 编译器 → [    ]目标文件 →
				                                ↓
				链接库 → 链接器←←←←←←←←←←←←←←←←←←←
				           ↓
				       可执行程序

				每个 源文件 都是单独处理的

				.obj 目标文件
				.lib 静态库

				编译：
					组成一个程序的每个源文件（.c文件）通过编译过程分别转换成目标代码（.obj文件）(object code)。
				链接：
					每个目标文件由链接器（linker）捆绑在一起，形成一个单一而完整的可执行程序（.exe文件）。

					链接器同时也会引入标准C函数库中任何被该程序所用到的函数，
					而且它可以搜索程序员个人的程序库，将其需要的函数也链接到程序中。


				test.c
				↓
				编译环境(VS2022集成开发环境)
					编译
						编译器cl.exe
							预编译(预处理)
								(*.i)
								(文本操作)
								#include 头文件的包含 (将源文件中以”include”格式包含的文件复制到编译的源文件中)
								#define 定义的符号和宏的替换 (用实际值替换用“#define”定义的字符串。)
								根据“#if”后面的条件决定需要编译的代码。
								删除注释
								......
								(gcc test.c -E)(gcc test.c -E > test.i)
							编译
								(*.s)
								把 C语言代码 转换成 汇编代码
								语法分析
								词法分析
								语义分析
								符号汇总
								(gcc test.i -S)
							汇编
								(*.o)(*.obj)
								(test.o 是elf格式的文件)(test.o 划分成了一个一个的段)(每一个段里存放的数据不同)(readelf命令，一般用于查看ELF格式的文件信息)
								把 汇编代码 转换成 机器指令(二进制指令)
								形成符号表
								(gcc test.s -c)
								(readelf test.o -s)
					链接
						链接器link.exe
							(*.out)(*.exe)
							(.out和.exe也是elf格式)
							把多个 目标文件 和 链接库 进行链接
							合并段表(相同段的数据合并)
							符号表的合并和符号表的重定位
				↓
				test.exe
				↓
				运行环境
				↓
				运行结果


			3.2 编译本身也分为几个阶段

				----------------------------------------------------------------------------------------------------------------------
				|    test.c  |  预编译阶段(*.i)  |  编译(*.s)  |  汇编(生成可重定目标文件*.o)     |  链接                              |
				|            |  预处理指令       |  语法分析   |  形成符号表                      |                                    |
				|            |                   |  词法分析   |  汇编指令->二进制指令--->test.o  |  1. 合并段表                       |
				|            |                   |  语义分析   |  汇编指令->二进制指令--->sum.o   |  2. 符号表的合并和符号表的重定位    |
				|    sum .c  |                   |  符号汇总   |                                 |                                    |
				|--------------------------------------------------------------------------------------------------------------------|
				|    隔离编译，一起链接                                                                                               |
				----------------------------------------------------------------------------------------------------------------------

				合并段表
					[ ] →← [ ]
					[ ] →← [ ]
					[ ] →← [ ]
					[ ] →← [ ]
					[ ] →← [ ]

				形成符号表
					(test.c里Add函数只是声明，没有确切地址)
					test.c    [Add] [0x0000]
					          [main][0x1004]

					sum.c     [Add] [0x1008]

				符号表的合并和符号表的重定位
					(筛选有效地址的符号)
					test.c    [Add] [0x0000] -
					          [main][0x1004]  |
					                          | → [Add] [0x1008]
					sum.c     [Add] [0x1008] -    [main][0x1004]
					(链接好的可执行程序，调用函数，通过地址就能找到函数)


			3.3 运行环境
				
				程序执行的过程

					1. 程序必须载入内存中。在有操作系统的环境中：一般这个由操作系统完成。
					   在独立的环境中，程序的载入必须由手工安排，也可能是通过可执行代码置入只读内存来完成。

					2. 程序的执行便开始。接着便调用main函数。

					3. 开始执行程序代码。这个时候程序将使用一个运行时堆栈（stack）(即前面学的函数栈帧)，存储函数的局部变量和返回地址。
					   程序同时也可以使用静态（static）内存，存储于静态内存中的变量在程序的整个执行过程一直保留他们的值。

					4. 终止程序。正常终止main函数；也有可能是意外终止。

		----------------------------------------------------------------

		4. 预定义符号介绍
			
			4.1 预定义符号
				__FILE__ 	//进行编译的源文件
				__LINE__ 	//文件当前的行号
				__DATE__ 	//文件被编译的日期
				__TIME__ 	//文件被编译的时间
				__STDC__ 	//如果编译器遵循ANSI C，其值为1，否则未定义

				这些预定义符号都是语言内置的。


			4.2 #define

				4.2.1 #define 定义标识符

					语法：
						#define name stuff

					例如：
						#define MAX 1000
						#define reg register		//为 register这个关键字，创建一个简短的名字
						#define do_forever for(;;)	//用更形象的符号来替换一种实现
						#define CASE break;case		//在写case语句的时候自动把 break写上。

						// 如果定义的 stuff过长，可以分成几行写，除了最后一行外，每行的后面都加一个反斜杠(续行符)。
						#define DEBUG_PRINT printf("file:%s\tline:%d\t \
							date:%s\ttime:%s\n" ,\
							__FILE__,__LINE__ , \
							__DATE__,__TIME__ )

					在define定义标识符的时候，尽量不要在最后加上 ;
					这样容易导致问题。
						
						#define MAX 1000;
						int a = MAX;

						替换过去就成了

						int a = 1000;;

				4.2.2 #define 定义宏

					#define 机制包括了一个规定，允许把参数替换到文本中，
					这种实现通常称为宏（macro）或定义宏（define macro）。

					宏的申明方式：
						#define name( parament-list ) stuff
									  参数列表         内容
									  参数列表 里的 参数 可以替换到 内容 里

						其中的 parament-list 是一个由逗号隔开的符号表，它们可能出现在stuff中。

					注意：
						参数列表的左括号必须与name紧邻。
						如果两者之间有任何空白存在，参数列表就会被解释为stuff的一部分。

						例如：
							             ↓↓
							#define SQUARE(x) x * x

					宏的使用方式：
						#define SQUARE(x) x * x

						printf("%d\n", SQUARE(3));

						这个宏接收一个参数x，
						将 SQUARE(3) 置于程序中，
						预处理器就会用下面这个表达式替换上面的表达式：
						3 * 3

						printf("%d\n", 3 * 3);

					警告：
					此时写法的宏有一定的问题：

						#define SQUARE(x) x * x

						printf("%d\n", SQUARE(3 + 1));// 16?

						替换后

						printf("%d\n", 3 + 1 * 3 + 1);// 7

					建议写法
						#define SQUARE(x) ((x) * (x))

					所以用于对数值表达式进行求值的宏定义都应该用这种方式加上括号，
					避免在使用宏时由于参数中的操作符或邻近操作符之间不可预料的相互作用。


				4.2.3 #define 替换规则

					在程序中扩展#define定义符号和宏时，需要涉及几个步骤。
						1. 在调用宏时，首先对参数进行检查，看看是否包含任何由#define定义的符号。如果是，它们首先被替换。
						2. 替换文本随后被插入到程序中原来文本的位置。对于宏，参数名被他们的值所替换。
						3. 最后，再次对结果文件进行扫描，看看它是否包含任何由#define定义的符号。
						   如果是，就重复上述处理过程。

					注意：
						1. 宏参数和#define 定义中可以出现其他#define定义的符号。但是对于宏，不能出现递归。
						2. 当预处理器搜索#define定义的符号的时候，字符串常量的内容并不被搜索。


				4.2.4 #和##

					如何把参数插入到字符串中？

					printf("hello world\n");
					和
					printf("hello" "world\n");
					处理方式一样

					字符串是有自动连接的特点的。

					#的作用
						把一个宏参数变成对应的字符串。

					##的作用
						##可以把位于它两边的符号合成一个符号。
						它允许宏定义从分离的文本片段创建标识符。

						注意：这样的连接必须产生一个合法的标识符。否则其结果就是未定义的。

			演示&讲解
				预定义符号介绍_预定义符号();
				预定义符号介绍_预定义符号_写日志();
				预定义符号介绍_井define_井和井井_参数插入到字符串中();
				预定义符号介绍_井define_井和井井_位于它两边的符号合成一个符号();

		----------------------------------------------------------------

		5. 预处理指令 #define

		----------------------------------------------------------------
		6. 宏和函数的对比
		----------------------------------------------------------------
		7. 预处理操作符#和##的介绍
		----------------------------------------------------------------
		8. 命令定义
		----------------------------------------------------------------
		9. 预处理指令 #include
		----------------------------------------------------------------
		10 预处理指令 #undef
		----------------------------------------------------------------
		11 条件编译
		----------------------------------------------------------------
		――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
*/
/*
		――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

		资料推荐

			《程序员的自我修养》

			简明 VIM 练级攻略
			https://coolshell.cn/articles/5426.html

			给程序员的VIM速查卡
			https://coolshell.cn/articles/5479.html
*/

#include "define.h"

void n2(int 换行次数, char* 换行符号, int 符号个数)
{
	int i = 0;

	if (换行符号 != NULL && 符号个数 > 0)
	{
		printf("\n");
		for (i = 0; i < 符号个数; i++)
		{
			printf("%s", 换行符号);
		}
	}

	for (i = 0; i < 换行次数; i++)
	{
		printf("\n");
	}
}

int 判断文件是否存在(char* 文件路径)
{
	FILE* pfff = fopen(文件路径, "r");

	if (pfff == NULL)
	{
		return 0;
	}

	fclose(pfff);
	pfff = NULL;

	return 1;
}

/**************************************************************************************************************************************************/
/*================================================================================================================================================*/

void 预定义符号介绍_预定义符号()
{
	printf("预定义符号介绍_预定义符号\n");

	printf("file:%s\nline:%d\ndata:%s\ntime:%s\n", __FILE__, __LINE__, __DATE__, __TIME__);
	printf("%s\n", __FUNCTION__);// 函数名

	n2(2, "-------- ", 4);
}

/*================================================================================================================================================*/

void 预定义符号介绍_预定义符号_写日志()
{
	printf("预定义符号介绍_预定义符号_写日志\n");

	if ((判断文件是否存在("..\\测试文件操作\\文件9-预定义符号介绍_预定义符号_写日志.txt")) == 0)
	{
		printf("文件可能不存在\n");
		return;
	}

	
	FILE* pf = fopen("..\\测试文件操作\\文件9-预定义符号介绍_预定义符号_写日志.txt", "a+");
	if (pf == NULL)
	{
		perror("fopen");
		return;
	}

	int i = 0;
	for (i = 0; i < 10; i++)
	{
		fprintf(pf, "file:%s line:%d data:%s time:%s i:%d\n", __FILE__, __LINE__, __DATE__, __TIME__, i);
	}


	fclose(pf);
	pf = NULL;

	n2(2, "-------- ", 4);
}

/*================================================================================================================================================*/

// 错误写法
//#define 打印(x) printf("变量" x "是%d\n", x);

#define 宏_打印(x) printf("变量" #x "是%d\n", x);

#define 宏修改_打印(x, 格式) printf("变量" #x "是" 格式 "\n", x);

void 打印(int x)
{
	////     此处没法改变
	////          ↓
	//printf("变量x是%d\n", x);
}

void 预定义符号介绍_井define_井和井井_参数插入到字符串中()
{
	printf("预定义符号介绍_井define_井和井井_参数插入到字符串中\n");

	printf("hello world\n");
	printf("hello " "world\n");

	// 希望打印：变量a是10
	int a = 10;

	// 希望打印：变量b是20
	int b = 20;

	// 希望打印：变量c是30
	int c = 30;

	// 如果写成函数
	打印(a);
	打印(b);
	打印(c);

	// 宏
	宏_打印(a);
	宏_打印(b);
	宏_打印(c);
	// printf("变量" #x "是%d\n", x);
	// 替换成 参数所对应的字符串
	// printf("变量" "a" "是%d\n", a);

	// 宏 修改
	float f = 5.5f;
	宏修改_打印(f, "%f");
	// printf("变量" #x "是" 格式 "\n", x);
	// 替换成 
	// printf("变量" "f" "是" "%f" "\n", f);


	n2(2, "-------- ", 4);
}

/*================================================================================================================================================*/

#define CAT(X, Y) X##Y

void 预定义符号介绍_井define_井和井井_位于它两边的符号合成一个符号()
{
	printf("预定义符号介绍_井define_井和井井_位于它两边的符号合成一个符号\n");

	int class101 = 100;
	printf("%d\n", CAT(class, 101));
	// ↓
	// printf("%d\n", class##101);
	// ↓
	// printf("%d\n", class101);

	n2(2, "-------- ", 4);
}

/*================================================================================================================================================*/

int main()
{
	预定义符号介绍_预定义符号();
	预定义符号介绍_预定义符号_写日志();
	预定义符号介绍_井define_井和井井_参数插入到字符串中();
	预定义符号介绍_井define_井和井井_位于它两边的符号合成一个符号();

	return 0;
}

/*================================================================================================================================================*/
/**************************************************************************************************************************************************/