/*
	编码的三种境界：
		1.看代码就是代码
		2.看代码就是内存
		3.看代码还是代码(编程像说话一样流畅)

	指针进阶
		1.字符指针
		2.数组指针
		3.指针数组
		4.数组传参和指针传参
		5.函数指针
		6.函数指针数组
		7.指向函数指针数组的指针
		8.回调函数
		9.指针和数组面试题的解析

		======== ======== ======== ======== ========

		指针初阶我们知道了指针的概念
			1.指针就是个变量，用来存放地址，地址唯一标识一块内存空间
			2.指针的大小是固定的4/8个字节(32位平台/64位平台)
			3.指针是有类型，指针的类型决定了指针的+-整数的步长，指针解引用操作的时候的权限
			4.指针的运算

		======== ======== ======== ======== ========

		1.字符指针
			char*

			一般使用
				char ch = 'w';
				char* pc = &ch;
				*pc = 'w';

			还有一种
				// 本质上是把"hello bit"这个字符串的首字符的地址存储在了ps中
				// 和char arr[] = "hello bit";不同，这种写法一定是把"hello bit"这个字符串放在了arr里
				char* ps = "hello bit";
				char arr[] = "hello bit";
				printf("%c\n", *ps);// h
				printf("%s\n", ps);// 打印字符串的时候给个起始位置的地址就能打印出来了
				printf("%s\n", arr);


			后面的hello bit.是常量字符串
				char* str3 = "hello bit.";

				严格写法
					const char* str3 = "hello bit.";
					虽然是常量字符串，但是*str3 = 'w';不会报错，加上const就会显示报错，语法更严谨

					const放在*的左边修饰的是指针指向的内容不能被修改

					(左边指向内容不能被修改,右边指向地址不能被修改)

		-------- -------- -------- -------- --------

		2.数组指针

			整形指针 指向整形的指针
			字符指针 指向字符的指针

			数组指针的定义
				数组指针是指针

				数组指针是 能够指向数组的指针

			定义一个数组指针
				int (*parr)[10];

				讲解在
					数组指针()

			&数组名 和 数组名

				&arr表示的是数组的地址，而不是数组首元素地址
				arr数组名是数组首元素的地址

				讲解在
					数组指针2_取地址数组名和数组名()

			数组指针的使用
				既然数组指针指向的是数组，那数组指针中存放的应该是数组的地址

				一般不会在一维数组中使用

				讲解在
					数组指针3_数组指针的使用_一维数组()
					数组指针4_数组指针的使用_二维数组()

		-------- -------- -------- -------- --------

		3.指针数组
			指针数组是一个存放指针的数组

			复习：
				int* arr[10];	// 整形指针的数组
				char* arr2[4];	// 一级字符指针的数组
				char** arr3[5]	// 二级字符指针的数组

			讲解在
				指针数组()
				指针数组2()

		-------- -------- -------- -------- --------

		4.数组传参和指针传参

			一维数组传参
				void test(int arr[]){}
				void test(int arr[10]){}
				void test(int *arr){}
				void test(int *arr[20]){}//20可以省略
				void test(int **arr){}

				int main()
				{
					int arr[10] = { 0 };
					int* arr2[20] = { 0 };
					test(arr);
					test2(arr2);
				}

			二维数组传参
				void test(int arr[3][5]){}
				void test(int arr[][]){}	// 错，行可以省略，列不能省略
				void test(int arr[3][5]){}
				void test(int *arr){}		// 错，传过来的是第一行的地址，一维数组的地址，不能拿一级指针接收
				void test(int *arr[5]){}	// 错，形参部分是一个数组，不是指针
				void test(int (*arr)[5]){}
				void test(int **arr){}		// 错，传过来的不是二级指针

				int main()
				{
					int arr[3][5] = { 0 };
					test(arr);
				}

			不管是一维还是二维数组，一定要分清传过去的是什么，接收的又是什么，两者要对应



			一级指针传参
				指针变量传参 指针变量接收

				char ch = 'w';
				char* pc = &ch;

				test(&ch);// ch是一个char类型的变量，取它的地址，它的类型就是char*
				或
				test(pc);

				一级指针传参，一级指针接收

				讲解在
					一级指针传参()

				一级指针
					int* p;		整形指针，指向整形的指针
					char* pc;	字符指针，指向字符的指针
					void* pv;	无类型的指针

			二级指针传参
				二级指针传参，二级指针接收

				讲解在
					二级指针传参()
					

		-------- -------- -------- -------- --------

		5.函数指针
			指向函数的指针
			存放函数地址的指针

			&函数名，取到的就是函数的地址

			数组名 != &数组名
			函数名 == &函数名

			函数没有首元素地址

			讲解在
				函数指针()
				函数指针2()

		-------- -------- -------- -------- --------
		-------- -------- -------- -------- --------
		======== ======== ======== ======== ========

		数组名是数组首元素的地址
		但是有2个例外，只有这2个例外
			1.sizeof(数组名) - 数组名表示整个数组，计算的是整个数组大小，单位是字节
			2.&数组名 - 数组名表示整个数组，取出的是整个数组的地址


		int arr[5];				整形数组
		int *parr1[10];			指针数组
		int (*parr2)[10];		数组指针，该指针能够指向一个数组，数组10个元素，每个元素的类型是int
		int (*parr3[10])[5];	parr3是一个存放数组指针的数组，该数组能存放10个数组指针，每个数组指针能指向一个数组，数组5个元素，每个元素是int类型。
								挖掉parr3[10]剩下的就是这个数组parr3里面元素的类型。

*/

#include "define.h"

void n()
{
	printf("\n");
}

//题目
//以下程序运行结果是什么？
void 题目1()
{
	printf("%s\n", "题目1");

	char str1[] = "hello bit.";
	char str2[] = "hello bit.";
	char* str3 = "hello bit.";
	char* str4 = "hello bit.";

	if (str1 == str2)// 不相同
	{
		printf("str1 and str2 are same\n");
	}
	else
	{
		printf("str1 and str2 are not same\n");
	}

	if (str3 == str4)// 相同
	{
		printf("str3 and str4 are same\n");
	}
	else
	{
		printf("str3 and str4 are not same\n");
	}

	/*
		str1和str2是两个数组
				  str1 指向的是空间1的
					↓
			空间1	hello bit.
			空间2	hello bit.
					↑
				  str2 指向的是空间2的

		str3和str4
			因为"hello bit."是常量字符串，
			两份相同的数据并且不能改，所以内存中只存一份

				  str3 指向的是空间3的
					↓
			空间3	hello bit.
					↑
				  str4 指向的是空间3的

		严格写法
			const char* str3 = "hello bit.";
			虽然是常量字符串，但是*str3 = 'w';不会报错，加上const就会显示报错，语法更严谨


		题目来自《剑指offer》49页
	*/

	n();
}

//章节内容讲解
void 指针数组()
{
	printf("%s\n", "指针数组");

	// 以下这样写应用场景非常少
	int a = 10;
	int b = 20;
	int c = 30;
	int* arr[3] = { &a,&b,&c };//存放整形指针的数组
	int i = 0;
	for (i = 0; i < 3; i++)
	{
		printf("%d ", *(arr[i]));// arr[i]现在是一个地址，括起来然后解引用，就找到了对应的值
	}

	n();
	n();
}

void 指针数组2()
{
	printf("%s\n", "指针数组2");

	int a[5] = { 1,2,3,4,5 };
	int b[] = { 2,3,4,5,6 };
	int c[] = { 3,4,5,6,7 };

	int* arr[3] = { a,b,c };

	int i = 0;
	for (i = 0; i < 3; i++)
	{
		int j = 0;
		for (j = 0; j < 5; j++)
		{
			//printf("%d ", *(arr[i] + j));// arr[i]+j可以理解为arr[0] = a 里的 下标0的元素
			printf("%d ", arr[i][j]);// 可以写成这样，[j]可以转变为+j解引用
		}
		printf("\n");
	}

	/*
		模拟了二维数组，但是不是二维数组，二维数组里的元素是连续存放的
		现在这样写的里面三行都是独立的，只不过有前面有三个指针(a,b,c)统领起来了，让我们感觉像二维数组
	*/
	n();
}

void 数组指针()
{
	printf("%s\n", "数组指针");
	/*
		arr						数组名是首元素的地址 - arr[0]的地址
		&arr					取出的是数组的地址
		int* parr = &arr		这样写不正确，这颗*说明parr是指针，指向的是int
		int* parr[10] = &arr	这样写不正确，parr和[]在一起，parr就是数组了

		int (*parr)[10] = &arr
		正确，
		*和parr在一起说明parr是指针，
		[]表示指向的是一个数组，
		[]里面的10表示指向的数组里面有10个元素，
		int表示指向的数组里面的每个元素是int类型

		现在parr就是一个数组指针

		int (*parr)[10] = &arr
		去掉指针名字parr
		剩下的 int (*)[10] 就是数组指针的类型
	*/
	int arr[10] = { 1,2,3,4,5 };
	double* d[5];// 数组d，[5]有5个元素，每个元素类型是double*

	int(*parr)[10] = &arr;
	double* (*pd)[5] = &d;// *说明pd是指针，[5] 指向的是数组 5个元素，每个元素类型是double*

	n();
}

void 数组指针2_取地址数组名和数组名()
{
	printf("%s\n", "数组指针2_取地址数组名和数组名");
	// &数组名 和 数组名

	int arr[10] = { 0 };

	printf("%p\n", arr);
	printf("%p\n", &arr);

	n();

	int* p1 = arr;
	int(*p2)[10] = &arr;
	printf("%p\n", p1);
	printf("%p\n", p1 + 1);// 跳过一个整形
	printf("%p\n", p2);
	printf("%p\n", p2 + 1);// 跳过一个数组


	/*
		printf("%p\n", arr);
		printf("%p\n", &arr);
		虽然输出结果一样，但是意义不同
			类型不一样
			就像
				char c = 'a';	//a的Ascll码值是97，char类型
				int i = 97;		//97 int类型

		&arr表示的是数组的地址，而不是数组首元素地址
		arr数组名是数组首元素的地址
	*/
	n();
}

void 数组指针3_数组指针的使用_一维数组()
{
	printf("%s\n", "数组指针3_数组指针的使用_一维数组");

	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	int(*pa)[10] = &arr;
	int i = 0;
	for (i = 0; i < 10; i++)
	{
		printf("%d ", *((*pa) + i));
	}

	/*
		*pa对数组指针pa解引用，找到了整个数组，整个数组没法一个个打印
		*pa当他是整个数组的时候，相当于拿到了数组名，*pa相当于数组arr的数组名
		数组名相当于首元素的地址，元素1的地址，通过元素1的地址把所有元素打印出来

		这种写法太别扭

		因为指针*pa存的是arr的地址,解引用找到arr的地址然后解引用+1后的地址
			*((*pa) + i)
			*((arr) + i)
			arr[i]

		(对于数组指针来说，(*p)是取地址，而不是取地址里面的值，*(*p)才是取值)
	*/
	n();
	n();
}

void 数组指针4_数组指针的使用_二维数组_打印(int(*p)[5], int 行, int 列)
{
	/*
		用指针形式写法的话，这里理所应当的用数组指针
		p是一个数组指针，指向一维数组的，指向二维数组的某一行

		p是指向第一行
		p+i 是指向了某一行，p+0没跳过行，p+1指向了第二行，p+2指向了第三行
		*(p+i)某一行解引用，找到了某一行的数组名

			二维数组的每一行的数组名：
									arr[0]		  arr[1]	   arr[2]
				int arr[3][5] = { {1,2,3,4,5}, {2,3,4,5,6}, {3,4,5,6,7} };
								   ↑
								arr[0]数组名相当于首元素地址

		找到了某一行的首元素地址，然后*(p+i) + j，就找到了下标为j元素的地址
		然后括号括起来(*(p+i) + j)，再解引用*(*(p+i) + j)，就找到了第i行，下标为j的元素
		然后就可以打印出来printf("%d ", *(*(p + i) + j));
	*/
	int i = 0;
	int j = 0;
	for (i = 0; i < 行; i++)
	{
		for (j = 0; j < 列; j++)
		{
			printf("%d ", *(*(p + i) + j));
		}
		n();// 每行打印完换行
	}
}
void 数组指针4_数组指针的使用_二维数组()
{
	printf("%s\n", "数组指针4_数组指针的使用_二维数组");

	int arr[3][5] = { {1,2,3,4,5}, {2,3,4,5,6}, {3,4,5,6,7} };
	数组指针4_数组指针的使用_二维数组_打印(arr, 3, 5);
	/*
		二维数组的数组名表示 首元素的地址
		二维数组的首元素是：第一行

		第一行是5个整形的一维数组
		二维数组的第一行的地址就是一个一维数组的地址

		假设一维数组名字为 a，int a[5];
		相当于拿到了 &a

		形参就可以写成 int(*p)[5]
	*/
	n();
}

void 一级指针传参_打印(int* ptr, int sz)
{
	int i = 0;
	for (i = 0; i < sz; i++)
	{
		printf("%d ", *(ptr + i));
	}
}
void 一级指针传参()
{
	printf("%s\n", "一级指针传参");

	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	int* p = arr;
	int sz = sizeof(arr) / sizeof(arr[0]);

	// p是一级指针
	一级指针传参_打印(p, sz);

	/*
		指针变量传参 指针变量接收

		char ch = 'w';
		char* pc = &ch;

		test(&ch);// ch是一个char类型的变量，取它的地址，它的类型就是char*
		或
		test(pc);

		一级指针传参，一级指针接收
	*/

	n();
	n();
}

void 二级指针传参_test(int** p2)
{
	**p2 = 20;// *p2解引用找到pa，**p2再解引用找到a
}
void 二级指针传参()
{
	printf("%s\n", "二级指针传参");

	int a = 10;
	int* pa = &a;	// pa是一级指针
	int** ppa = &pa;// ppa是二级指针

	二级指针传参_test(ppa);
	/*
		// 以下都行
		二级指针传参_test(&pa);// 传一级指针变量的地址

		int* arr[10] = { 0 };// 存放整形指针的数组，每个元素类型是int*
		二级指针传参_test(arr);// 传存放一级指针的数组
	*/
	printf("%d\n", a);

	n();
}

int 函数指针_Add(int x, int y)
{
	return x + y;
}
void 函数指针()
{
	printf("%s\n", "函数指针");

	printf("%p\n", &函数指针_Add);// &函数名，取到的就是函数的地址
	printf("%p\n", 函数指针_Add);

	int (*pf)(int, int) = &函数指针_Add;// pf就是一个函数指针变量

	int ret = (*pf)(3, 5);// 调用 传参，ret变量接收返回值
	printf("%d\n", ret);

	n();
}

void 函数指针2()
{
	printf("%s\n", "函数指针2");

	//int (*pf)(int, int) = &函数指针_Add;
	int (*pf)(int, int) = 函数指针_Add;// 函数指针_Add === pf

	int ret = pf(3, 5);
	printf("%d\n", ret);

	/*
		这3种写法完全等价
		int ret = (*pf)(3, 5);
		int ret = pf(3, 5);
		int ret = 函数指针_Add(3, 5);

		(*pf)里的*只是摆设，只是看起来更好理解，里面的*再多也是一样，例如(********pf)
	*/

	n();
}

int main()
{
	题目1();


	指针数组();

	指针数组2();

	数组指针();

	数组指针2_取地址数组名和数组名();

	数组指针3_数组指针的使用_一维数组();

	数组指针4_数组指针的使用_二维数组();

	一级指针传参();

	二级指针传参();

	函数指针();

	函数指针2();

	n();


	return 0;
}