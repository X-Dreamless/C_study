/*
	Lesson2--算法的 时间复杂度 和 空间复杂度

		本节目标
			1. 算法效率
			2. 时间复杂度
			3. 空间复杂度
			4. 常见时间复杂度以及复杂度oj练习

		======== ======== ======== ======== ======== ======== ========
		-------- -------- -------- -------- -------- -------- --------

			1.算法效率

				算法效率分析分为两种：第一种是时间效率，第二种是空间效率。时间效率被称为时间复杂度，而空间效率
				被称作空间复杂度。 时间复杂度主要衡量的是一个算法的运行速度，而空间复杂度主要衡量一个算法所需要
				的额外空间，在计算机发展的早期，计算机的存储容量很小。所以对空间复杂度很是在乎。但是经过计算机
				行业的迅速发展，计算机的存储容量已经达到了很高的程度。所以我们如今已经不需要再特别关注一个算法
				的空间复杂度。

				1.1 如何衡量一个算法的好坏？

					比如以下斐波那契数列：

						long long Fib(int N)
						{
							if (N < 3)
							{
								return 1;
							}
							return Fib(N - 1) + Fib(N - 2);
						}

					斐波那契数列的递归实现方式非常简洁，但简洁一定好吗？那该如何衡量其好与坏呢？


				1.2 算法的复杂度

					算法在编写成可执行程序后，运行时需要消耗时间资源和空间(内存)资源，因此衡量一个算法的好坏，
					一般是从时间和空间两个维度来衡量的，即 时间复杂度 和 空间复杂度。

					时间复杂度主要衡量一个算法的运行快慢，而空间复杂度主要衡量一个算法运行所需要的额外空间。
					在计算机发展的早期，计算机的存储容量很小。所以对空间复杂度是很在乎。但是经过计算机行业的迅速发展。
					计算机的存储容量已经达到了很高的程度。所以我们如今已经不需要再特别关注一个算法的空间复杂度。

					摩尔定律
						归纳起来，“摩尔定律”主要有以下3种“版本”：
							1、集成电路芯片上所集成的电路的数目，每隔18个月就翻一番。
							2、微处理器的性能每隔18个月提高一倍，而价格下降一半。
							3、用一美元所能买到的计算机性能，每隔18个月翻两番。


				1.3 复杂度在校招中的考察

		-------- -------- -------- -------- -------- -------- --------

		2. 时间复杂度

			2.1 时间复杂度的概念

				时间复杂度的定义：在计算机科学中，算法的时间复杂度是一个函数(数学里面带有未知数的函数表达式)，它定量描述了该算法的运行时间。
				一个算法执行所耗费的时间，从理论上说，是不能算出来的，只有你把你的程序放在机器上跑起来，才能知道。
				但是我们需要每个算法都上机测试吗？是可以都上机测试，但是这很麻烦，所以才有了时间复杂度这个分析方式。
				一个算法所花费的时间与其中语句的执行次数成正比例，算法中的基本操作的执行次数，为算法的时间复杂度。

				即：找到某条基本语句与问题规模N之间的数学表达式，就是算出了该算法的时间复杂度。

				实际中我们计算时间复杂度时，我们其实并不一定要计算精确的执行次数，而只需要大概执行次数，
				那么这里我们使用大O的渐进表示法。

				大O的渐进表示法(估算)
					O()


			2.2 大O的渐进表示法

				大O符号（Big O notation）：是用于描述函数渐进行为的数学符号。

				推导大O阶方法：
					1、用常数1取代运行时间中的所有加法常数。
					2、在修改后的运行次数函数中，只保留最高阶项。
					3、如果最高阶项存在且不是1，则去除与这个项目相乘的常数。得到的结果就是大O阶。


				使用大O的渐进表示法以后，Func1的时间复杂度为：
					O(N^2)
					N = 10 F(N) = 100
					N = 100 F(N) = 10000
					N = 1000 F(N) = 1000000

				通过上面我们会发现大O的渐进表示法去掉了那些对结果影响不大的项，简洁明了的表示出了执行次数。
				另外有些算法的时间复杂度存在最好、平均和最坏情况：
					最坏情况：任意输入规模的最大运行次数(上界)
					平均情况：任意输入规模的期望运行次数
					最好情况：任意输入规模的最小运行次数(下界)

				例如：在一个长度为N数组中搜索一个数据x
					最好情况：1次找到
					最坏情况：N次找到
					平均情况：N/2次找到

				在实际中一般情况关注的是算法的最坏运行情况，所以数组中搜索数据时间复杂度为O(N)


			2.3常见时间复杂度计算举例

				实例1：计算Func2的时间复杂度？				-双重循环时间复杂度的计算
				实例2：计算Func3的时间复杂度？				-双重循环时间复杂度的计算
				实例3：计算Func4的时间复杂度？				-常数循环的时间复杂度
				实例4：计算strchr的时间复杂度？				-在字符串中查找首次出现的字符
				实例5：计算BubbleSort的时间复杂度？			-冒泡排序的时间复杂度
				实例6：计算BinarySearch的时间复杂度？			-二分查找
				实例7：计算阶乘递归Factorial的时间复杂度？	-
				实例8：计算斐波那契递归Fibonacci的时间复杂度？-

				实例答案及分析：
					1. 实例1基本操作执行了2N+10次，通过推导大O阶方法知道，时间复杂度为 O(N)
					2. 实例2基本操作执行了M+N次，有两个未知数M和N，时间复杂度为 O(N+M)
					3. 实例3基本操作执行了10次，通过推导大O阶方法，时间复杂度为 O(1)
					4. 实例4基本操作执行最好1次，最坏N次，时间复杂度一般看最坏，时间复杂度为 O(N)
					5. 实例5基本操作执行最好N次，最坏执行了(N*(N+1)/2次，通过推导大O阶方法+时间复杂度一般看最
					   坏，时间复杂度为 O(N^2)
					6. 实例6基本操作执行最好1次，最坏O(logN)次，时间复杂度为 O(logN) ps：logN在算法分析中表示是底
					   数为2，对数为N。有些地方会写成lgN。（建议通过折纸查找的方式讲解logN是怎么计算出来的）
					7. 实例7通过计算分析发现基本操作递归了N次，时间复杂度为O(N)。
					8. 实例8通过计算分析发现基本操作递归了2^N次，时间复杂度为O(2^N)。（建议画图递归栈帧的二叉树
					   讲解）


			演示&讲解
				时间复杂度_时间复杂度的概念();

		-------- -------- -------- -------- -------- -------- --------
		3. 空间复杂度
		-------- -------- -------- -------- -------- -------- --------
		4. 常见时间复杂度以及复杂度oj练习
		-------- -------- -------- -------- -------- -------- --------
		======== ======== ======== ======== ======== ======== ========

*/

#include "My_function.h"

/**************************************************************************************************************************************************/
/*================================================================================================================================================*/

// -嵌套循环时间复杂度的计算
// 计算Func1中++count语句总共执行了多少次？
void Func1(int N)
{
	int count = 0;

	int i = 0;
	int j = 0;
	for (i = 0; i < N; i++)
	{
		for (j = 0; j < N; j++)
		{
			++count;
		}
	}

	for (int k = 0; k < 2 * N; k++)
	{
		++count;
	}

	int M = 10;
	while (N--)
	{
		++count;
	}

	printf("%d\n", count);

	// 计算Func1中++count语句总共执行了多少次？
	// 
	// 未知数
	//   ↓
	// F(N) = N * N + 2 * N + 10
	// 时间复杂度的函数式

	/*
		F(N) = N * N + 2 * N + 10

		Func1 执行的基本操作次数 ：
			N = 10 F(N) = 130
			N = 100 F(N) = 10210
			N = 1000 F(N) = 1002010


		只关注影响最大的项
		F(N) = N ^ 2
		N = 100 F(N) = 10000
		N = 1000 F(N) = 1000000

		F(N) = N * N + 2 * N + 10
					   __________
		N越大，后两项对结果的影响是越小的


		保留N * N这一项，因为这一项影响结果最大
		时间复杂度：O(N ^ 2)
	*/
}

// 实例1：
// 计算Func2的时间复杂度？
void Func2(int N)
{
	int count = 0;
	for (int k = 0; k < 2 * N; ++k)
	{
		++count;
	}
	int M = 10;
	while (M--)
	{
		++count;
	}
	printf("%d\n", count);

	/*
		F(N) = 2 * N + 10

		3、如果最高阶项存在且不是1，则去除与这个项目相乘的常数(系数)。得到的结果就是大O阶。

		O(N)
	*/
}

// 实例2：
// 计算Func3的时间复杂度？
void Func3(int N, int M)
{
	int count = 0;
	for (int k = 0; k < M; ++k)
	{
		++count;
	}
	for (int k = 0; k < N; ++k)
	{
		++count;
	}
	printf("%d\n", count);

	/*
		无 说明M和N的大小关系
			O(M+N)

		有 说明M和N的大小关系
			M远大于N -> O(M)
			N远大于M -> O(N)
			M和N差不多大 -> O(M) 或是 O(N)

		一般情况下 时间复杂度计算时未知数都是用 N，
		但是也是可以是 M，K 等等其他的。
	*/
}

// 实例3：
// 计算Func4的时间复杂度？
void Func4(int N)
{
	int count = 0;
	for (int k = 0; k < 100; ++k)
	{
		++count;
	}
	printf("%d\n", count);

	/*
		1、用常数1取代运行时间中的所有加法常数。

		O(1)

		O(1)不是代表算法运行一次，是常数次
	*/
}

void 在字符串中查找首次出现的字符()
{
	// 实例4:
	// 计算strchr的时间复杂度？
	const char* strchr(const char* str, int character);
	/*
		const char * strchr ( const char * str, int character );
		char * strchr (       char * str, int character );
		库函数 在字符串中查找首次出现的字符

		相当于
			while (*str)
			{
				if (*str == character)
				{
					return str;
				}
				else
				{
					++str;
				}
			}

		另外有些算法的时间复杂度存在最好、平均和最坏情况：
			最坏情况：任意输入规模的最大运行次数(上界)
			平均情况：任意输入规模的期望运行次数
			最好情况：任意输入规模的最小运行次数(下界)

		假设在 hello world 中查找
			查找 h 最好情况 1
			查找 w 平均情况 N/2
			查找 d 最坏情况 N

		当一个算法随着输入不同，时间复杂度不同，时间复杂度看最坏的情况

		O(N)
	*/
}

// 实例5：
void Swap(int* x, int* y)// 交换函数
{
	int temp = *y;
	*y = *x;
	*x = temp;
}

// 计算BubbleSort的时间复杂度？
void BubbleSort(int* a, int n)
{
	assert(a);
	for (size_t end = n; end > 0; --end)
	{
		int exchange = 0;
		for (size_t i = 1; i < end; ++i)
		{
			if (a[i - 1] > a[i])
			{
				Swap(&a[i - 1], &a[i]);
				exchange = 1;
			}
		}
		if (exchange == 0)
			break;
	}

	/*
		冒泡排序的时间复杂度

		等差数列
			N
			N-1
			N-2
			......
			1

		比较数据 严格来说
			N-1
			N-2
			N-3
			......
			1


		F(N) = N*(N-1)/2

		O(N^2)
	*/
}

// 实例6：
// 计算BinarySearch的时间复杂度？
int BinarySearch(int* a, int n, int x)
{
	assert(a);
	int begin = 0;
	int end = n - 1;
	while (begin < end)
	{
		int mid = begin + ((end - begin) >> 1);
		if (a[mid] < x)
			begin = mid + 1;
		else if (a[mid] > x)
			end = mid;
		else
			return mid;
	}
	return -1;

	/*
		二分查找
			O(logN)

		最好情况 O(1)

		最坏情况 O(log₂N)
			最边上 和 找不到

			假设查找X次
			找了多少次就乘了多少个2
			1*2*2*2...... = N
			N 是数组大小

			N/2/2/2...... = 1
			2^X = N
			X = log₂N


		N个数中查找		大概查找次数
		1000			10		2¹⁰ = N
		1000000			20		2²⁰ = N

		前提是有序


		查找相关的：
			数 -> 二叉树 -> 搜索二叉树 -> 平衡搜索二叉树 -> AVL数 -> 红黑树
				不需要排序，查找效率可以达到 log₂N

			哈希表

			B树系列


	*/
}

// 实例7：
// 计算阶乘递归Factorial的时间复杂度？
long long Factorial(size_t N)
{
	return N < 2 ? N : Factorial(N - 1) * N;

	/*
		long long Factorial(size_t N)
		{
			if (0 == N)
			{
				return 1;
			}

			return Factorial(N - 1) * N;
		}

		递归算法：递归次数*每次递归调用的次数

		每次递归都是常数，每次是O(1)，递归了N次

		O(N)
	*/
}

// 实例8：
// 计算斐波那契递归Fibonacci的时间复杂度？
long long Fibonacci(size_t N)
{
	return N < 2 ? N : Fibonacci(N - 1) + Fibonacci(N - 2);

	/*
		long long Fibonacci(size_t N)
		{
			if (N < 3)
			{
				return 1;
			}

			return Fibonacci(N - 1) + Fibonacci(N - 2);
		}

		递归算法：递归次数*每次递归调用的次数

						Fib(N)					2⁰
			Fib(N-1)			Fib(N-2)		2¹
		Fib(N-2) Fib(N-3)	Fib(N-3) Fib(N-4)	2²
												2^N-1

		等比数列

		Fib(N) = 2^0 + 2^1 + 2^2 + ...... + 2^(N-1) - X
		X为缺少的递归调用次数，可以忽略不计
		右边一些递归分支会提前结束

		等比数列公式计算后得

		2^N-1

		X 远小于 2^N

		时间复杂度：O(2^N)

		斐波那契数列的递归写法太慢了
	*/
}



void 时间复杂度_时间复杂度的概念()
{
	printf("文字\n");

	Func1(1);
	Func2(1);
	Func3(1, 1);
	Func4(1);
	在字符串中查找首次出现的字符();
	BubbleSort(NULL, 1);
	BinarySearch(NULL, 1, 1);
	Factorial(1);
	Fibonacci(1);

	n2(2, "-------- ", 4);
}

/*================================================================================================================================================*/

int main()
{
	时间复杂度_时间复杂度的概念();

	return 0;
}

/*================================================================================================================================================*/
/**************************************************************************************************************************************************/