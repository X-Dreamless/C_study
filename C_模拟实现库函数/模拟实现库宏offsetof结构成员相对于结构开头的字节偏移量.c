/*
	模拟实现库宏offsetof结构成员相对于结构开头的字节偏移量

		起始位置
			0
			↓
			[a][a][a][a][b][b][ ][ ][c][c][c][c][d][ ][ ][ ]
			 0  1  2  3  4  5  6  7  8  9  10 11 12


		思路
			
			假设0地址处放了个结构体，
			则每个成员的地址就是他们的偏移量

			偏移量 = (成员起始地址 减 起始地址) = 成员的地址

			把0强转为结构体指针，向后可以访问一个结构体，认为后面存放了一个结构体变量
			然后可以用0位置这个指针访问结构体成员

			例如
				0x0012ff44
				这是一个普通的常数，
				一个数字如果写成：(int*)0x0012ff44
				就认为0x0012ff44这个地址处向后存放了一个整形，
				所以相当于在0地址处向后放了一个结构体

			1. 先将0转换为一个结构体类型的指针，相当于某个结构体的首地址是0。
			   此时，每一个成员的偏移量就成了相对0的偏移量，这样就不需要减去首地址了。

			2. 对该指针用->访问其成员，并取出地址，由于结构体起始地址为0，
			此时成员偏移量直接相当于对0的偏移量，所以得到的值 直接就是对首地址的偏移量。

			3. 取出该成员的地址，强转成int并打印，就求出了这个偏移量。

			(得到的是地址，而我们想要的是int，所以强转)

			注意：
				此处并没有在0地址位置开辟结构体空间，只是假设0地址处放了一个结构体，模拟的找到它的成员。
				(变量的定义才开辟空间)

				0就是一个数字，强转为结构体指针，类型发生了变化，值还是0，只是认为0是个地址编号。

				0强转为结构体指针，站在结构体指针的角度，认为0地址后面存放了一个结构体，通过这个地址可以找到它的成员。

				(指针的 类型 决定指针的 步长/访问权限)

				->相当于解引用操作，但是由于空间并没有被开辟出来，所以不是非法访问。

				相当于：我只是取出内存中看看其对应的值。

				只是看下0地址向后的成员的地址值。

*/

#include <stdio.h>
#include <stddef.h>

#define my_offsetof(类型,成员) (int)&(((类型*)0) -> 成员)

struct A
{
	int a;
	short b;
	int c;
	char d;
};

int main()
{
	printf("%d\n", offsetof(struct A, a));
	printf("%d\n", offsetof(struct A, b));
	printf("%d\n", offsetof(struct A, c));
	printf("%d\n", offsetof(struct A, d));

	printf("\n");

	printf("%d\n", my_offsetof(struct A, a));
	printf("%d\n", my_offsetof(struct A, b));
	printf("%d\n", my_offsetof(struct A, c));
	printf("%d\n", my_offsetof(struct A, d));

	return 0;
}