/*
	动态内存管理

		本章重点
			● 为什么存在动态内存分配
			● 动态内存函数的介绍
				○ malloc
				○ free
				○ calloc
				○ realloc

			● 常见的动态内存错误
			● 几个经典的笔试题
			● 柔性数组

		――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

		● 为什么存在动态内存分配
			
			我们已经掌握的内存开辟方式有
				int val = 20;			// 在栈空间上开辟4个字节
				char arr[10] = { 0 };	// 在栈空间上开辟10个字节的连续空间

			但是上述的开辟空间的方式有两个特点
				1. 空间开辟大小是固定的
				2. 数组在声明的时候，必须指定数组的长度，它所需要的内存在编译时分配

			但是对于空间的需求，不仅仅是上述的情况。有时候我们需要的空间大小在程序运行的时候才能知道，
			这时候就只能试试动态内存开辟了


			栈区
				局部变量
				函数形参

			堆区
				动态内存开辟

			静态区(数据段)
				全局变量
				静态变量

		----------------------------------------------------------------

		● 动态内存函数的介绍

			○ malloc 分配内存块

				<stdlib.h>

				void* malloc (size_t size);
									 开辟的字节数

				这个函数向内存申请一块连续可用的空间，并返回指向这块空间的指针

					1. 如果开辟成功，则返回一个指向开辟好空间的指针。
					2. 如果开辟失败，则返回一个NULL指针，因此 malloc 的返回值一定要做检查。
					3. 返回值的类型是void* ，所以 malloc 函数并不知道开辟空间的类型，
					   具体在使用的时候使用者自己来决定。
					4. 如果参数size为0，malloc 的行为是 标准是 未定义的，取决于编译器。

				演示&讲解
					动态内存函数malloc分配内存块();


			○ free 动态内存释放

				<stdlib.h>

				void free (void* ptr);

				C语言提供了另外一个函数free，专门是用来做动态内存的释放和回收的
				free函数用来释放动态开辟的内存
					1. 如果参数prt指向的空间不是动态开辟的，那free函数的行为是未定义的。
					   (free 只能释放堆区上开辟的空间的起始地址)
					2. 如果参数ptr是NULL指针，则函数什么事都不做。

				演示&讲解
					动态内存函数malloc分配内存块();
					动态内存函数calloc分配内存块并初始化();
					动态内存函数realloc重新分配();


			○ calloc 分配内存块并初始化
				
				<stdlib.h>

				void* calloc (size_t num, size_t size);
							  元素个数	, 每个元素的大小(字节)

				calloc函数也用来动态内存分配
					1. 函数的功能是为num个大小为size的元素开辟一块空间，
					   并且把空间的每个字节初始化为0
					2. 与函数 malloc 的区别只在于 calloc 会在返回地址之前把
					   申请的空间的每个字节初始化为全0

				演示&讲解
					动态内存函数calloc分配内存块并初始化();


			○ realloc 动态内存调整(重新分配)

				<stdlib.h>

				void* realloc (void* ptr, size_t size);

				1. realloc 函数的出现让动态内存管理更加灵活。
				2. 有时我们会发现过去申请的空间太小了，有时我们又会觉得申请的空间太大了，
				   那为了合理的时候内存，我们一定会对内存的大小做灵活的调整。
				3. ptr 是要调整的内存地址。
				4. size 调整之后新大小
				5. 返回值为调整之后的内存起始位置
				6. 这个函数调整原内存空间大小的基础上，还会将原来内存中的数据移动到新的空间。
				7. realloc 在调整内存空间存在两种情况
					情况1：原有空间之后有足够大的空间
						增加原有空间
						[1][2][3][4][5] + [ ][ ][ ][ ][ ]...[*][*][*]

					情况2：原有空间之后没有足够大的空间
						移动到新空间
						[1][2][3][4][5][*][*][*]
						↓
						[1][2][3][4][5][ ][ ][ ][ ][ ]...[*][*][*]

				演示&讲解
					动态内存函数realloc重新分配();
					动态内存函数realloc重新分配II();

		----------------------------------------------------------------

		● 常见的动态内存错误
		
		----------------------------------------------------------------

		● 几个经典的笔试题
		
		----------------------------------------------------------------

		● 柔性数组

		----------------------------------------------------------------
		――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
*/

#include "define.h"
#include <stdlib.h>

void n2(int 换行次数, char* 换行符号, int 符号个数)
{
	int i = 0;

	if (换行符号 != NULL && 符号个数 > 0)
	{
		printf("\n");
		for (i = 0; i < 符号个数; i++)
		{
			printf("%s", 换行符号);
		}
	}

	for (i = 0; i < 换行次数; i++)
	{
		printf("\n");
	}
}

/**************************************************************************************************************************************************/
/*================================================================================================================================================*/

void 动态内存函数malloc分配内存块()
{
	printf("动态内存函数malloc分配内存块\n");

	// 开辟10个整形的空间
	// 10 * sizeof(int)
	// int* p = malloc(10 * sizeof(int));// 建议强制类型转换
	int* p = (int*)malloc(10 * sizeof(int));

	// 使用前
	if (p == NULL)
	{
		perror("动态内存函数malloc分配内存块");
		return;
	}

	// 使用
	// [1][2][3][4][5][6][7][8][9][10]
	int i = 0;
	for (i = 0; i < 10; i++)
	{
		*(p + i) = i;// 解引用找到元素，赋值
	}

	// 查看
	for (i = 0; i < 10; i++)
	{
		printf("%d ", p[i]);// p[i] 等价于 *(p + i)
	}

	// 释放
	free(p);// p指向那块空间的起始位置，释放那块空间

	// 置空
	// free 并不会把p置空
	p = NULL;

	n2(2, "-------- ", 0);
}

/*================================================================================================================================================*/

void 动态内存函数calloc分配内存块并初始化()
{
	printf("动态内存函数calloc分配内存块并初始化\n");

	// malloc
	int* p = (int*)malloc(40);

	if (p == NULL)
	{
		return;
	}

	int i = 0;
	for (i = 0; i < 10; i++)
	{
		printf("%d\n", *(p + i));
	}

	free(p);

	/*----------------------------------- -----------------------------------*/

	// calloc
	p = (int*)calloc(10, sizeof(int));

	if (p == NULL)
	{
		return;
	}

	for (i = 0; i < 10; i++)
	{
		printf("%d\n", *(p + i));
	}

	free(p);
	p = NULL;

	n2(1, "-------- ", 0);
}

/*================================================================================================================================================*/

void 动态内存函数realloc重新分配()
{
	printf("动态内存函数realloc重新分配\n");

	int* p = (int*)calloc(10, sizeof(int));

	if (p == NULL)
	{
		return;
	}

	int i = 0;
	for (i = 0; i < 10; i++)
	{
		*(p + i) = 5;
	}

	// 这里需要p指向的空间更大，需要20个int的空间
	// 
	// p = realloc(p, 20 * sizeof(int));
	// 不能直接用之前的p来接收，因为realloc找不到合适的空间会返回空指针
	int* ptr = (int*)realloc(p, 20 * sizeof(int));// 不是增加的大小，是新的大小

	// 判断临时指针是否为空
	if (ptr != NULL)
	{
		p = ptr;
	}

	free(p);
	p = NULL;
	ptr = NULL;

	n2(1, "-------- ", 0);
}

/*================================================================================================================================================*/

void 动态内存函数realloc重新分配II()
{
	printf("动态内存函数realloc重新分配II\n");

	int* p = (int*)realloc(NULL, 40);// 这里功能类似于malloc，就是直接在堆区开辟40个字节

	n2(1, "-------- ", 4);
}

/*================================================================================================================================================*/

int main()
{
	动态内存函数malloc分配内存块();

	动态内存函数calloc分配内存块并初始化();

	动态内存函数realloc重新分配();
	动态内存函数realloc重新分配II();

	return 0;
}

/**************************************************************************************************************************************************/
