
/*
	第1阶段C++ 匠心之作 从0到1入门

	第2阶段实战-通讯录管理

	第3阶段-C++核心编程

		1 内存分区模型

		2 引用

		3 函数提高

		4 类和对象

			4.1 封装

			4.2 对象的初始化和清理

				4.2.1 构造函数和析构函数

				4.2.2 构造函数的分类及调用

				4.2.3 拷贝构造函数调用时机

				4.2.4 构造函数调用规则

				4.2.5 深拷贝与浅拷贝

				4.2.6 初始化列表

				4.2.7 类对象作为类成员

				4.2.8 静态成员

					静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员

					静态成员分为：

						静态成员变量
							所有对象共享同一份数据
							在编译阶段分配内存
							类内声明，类外初始化

						静态成员函数
							所有对象共享同一个函数
							静态成员函数只能访问静态成员变量
*/

#include <iostream>

using namespace std;

/* ======== ======== ======== ======== ======== ======== ======== ======== */

// 示例1 ：静态成员变量
class Person
{

public:

	static int m_A; //静态成员变量

	//静态成员变量特点：
	//1 在编译阶段分配内存
	//2 类内声明，类外初始化
	//3 所有对象共享同一份数据

private:
	static int m_B; //静态成员变量也是有访问权限的
};
int Person::m_A = 10;
int Person::m_B = 10;

void test01()
{
	//静态成员变量两种访问方式

	//1、通过对象
	Person p1;
	p1.m_A = 100;
	cout << "p1.m_A = " << p1.m_A << endl;

	Person p2;
	p2.m_A = 200;
	cout << "p1.m_A = " << p1.m_A << endl; //共享同一份数据
	cout << "p2.m_A = " << p2.m_A << endl;

	//2、通过类名
	cout << "m_A = " << Person::m_A << endl;


	//cout << "m_B = " << Person::m_B << endl; //私有权限访问不到
}

/* ======== ======== ======== ======== ======== ======== ======== ======== */

// 示例2：静态成员函数
class Person2
{

public:

	//静态成员函数特点：
	//1 程序共享一个函数
	//2 静态成员函数只能访问静态成员变量

	static void func()
	{
		cout << "func调用" << endl;
		m_A2 = 100;
		//m_B2 = 100; //错误，不可以访问非静态成员变量，无法区分是哪个对象的 m_B2

		/*
			静态 数据在内存中只有一份，
			m_B2 非静态成员变量，必须通过对象进行访问，需要创建一个对象，才能读写这块内存。

			来自弹幕：
				静态static成员函数它只属于类本身不属于每一个对象实例，独立存在。
				非静态成员，仅当实例化对象之后才存在。
				静态成员函数产生在前，非静态成员函数产生在后，静态函数无法访问一个不存在的东西。
		*/
	}

	static int m_A2; //静态成员变量
	int m_B2;        //成员变量
private:

	//静态成员函数也是有访问权限的
	static void func2()
	{
		cout << "func2调用" << endl;
	}
};
int Person2::m_A2 = 10;

void test02()
{
	//静态成员变量两种访问方式

	//1、通过对象
	Person2 p1;
	p1.func();

	//2、通过类名
	Person2::func();


	//Person2::func2(); //私有权限访问不到
}

/* ======== ======== ======== ======== ======== ======== ======== ======== */

int main()
{
	test01();

	test02();

	return 0;
}