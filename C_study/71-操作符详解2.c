/*
	操作符详解
		操作符和表达式
			1.各种操作符的介绍
			2.表达式求值

			操作符
				分类
					算数操作符
					移位操作符
					位操作符
					赋值操作符
					单目操作符
					关系操作符
					逻辑操作符
					条件操作符
					逗号表达式
					下标引用、函数调用和结构成员

					------------------------------------------

					算数操作符
						+
						-
						*
						/
						%

						1.除了%操作符之外，其他的几个操作符可以作用于整数和浮点数
						2.对于/操作符如果两个操作数都为整数，执行整数除法。而只要有浮点数执行的就是浮点数除法。
						3.%操作符的两个操作数必须为整数。返回的是整除之后的余数

					------------------------------------------

					移位操作符
						<< 左移
						>> 右移

						移位操作不会改变本身
							int c = 2;
							c << 1;
							printf("c = %d\n", c);// 2

						左移操作符 移位规则
							左边抛弃、右边补0

								int c = 2;
								// 把c的二进制位向左移动一位
								int c2 = c << 1;
								printf("c2 = %d\n", c2);

								// 整形变量 4字节 = 32比特位
								// 十进制2 = 二进制 [00000000 00000000 00000000 00000010]
								// 左移	0[0000000 00000000 00000000 000000100]
								//	    ↑									↑
								//	 溢出丢弃							   补0
								// 现在1来到了第三位，是2的2次方 = 4
								//

						右移操作符 移位规则
							1.算术右移
								右边丢弃，左边补原符号位

							2.逻辑右移
								右边丢弃，左边补0，不管正负数


							c6验证是 算术右移 还是 逻辑右移
								int c3 = 10;
								// 把c的二进制位向右移动一位 - 当前使用的是 算数右移
								int c4 = c3 >> 1;
								printf("c4 = %d\n", c4);
								// 十进制2 = 二进制 [00000000 00000000 00000000 00000010]
								// 右移	[000000000 00000000 00000000 0000101]0
								//		 ↑									 ↑
								//	    补0							      溢出丢弃

								// 用负数测试编译器是 算术右移 还是 逻辑右移 - 当前使用的是 算数右移
								int c5 = -1;
								int c6 = c5 >> 1;
								printf("c6 = %d\n", c6);
								// 负数 -1 存放在内存中 存放的是二进制的补码
								//
								// 整数的二进制表示形式：有3种
								//	原码：直接根据数值写出的二进制序列就是原码
								//	反码：原码的符号位不变，其他位按位取反就是反码
								//	补码：反码+1，就是补码
								//
								// -1原码：	[10000000 00000000 00000000 00000001]
								//			 ↑
								//		 这个1表示负数 符号位
								//
								// -1反码：	[11111111 11111111 11111111 11111110]
								//
								// -1补码：	[11111111 11111111 11111111 11111111]
								//
								// -1右移：	[ 1111111 11111111 11111111 11111111]1
								//			 ↑
								//		 算数补1原符号位，逻辑补0。补0就变正数

								原码 反码 补码 这个算法只针对负数，正整数的原码反码补码相同

					------------------------------------------

					位操作符
						& 按位与
						| 按位或
						^ 按位异或

						注：他们的操作数必须是整数

						int d = 3;	// 00000000 00000000 00000000 00000011
						int d2 = 5;	// 00000000 00000000 00000000 00000101
						// & - 按(二进制)位与 - 计算的位置相同是1，不同是0
						int d3 = d & d2; // 00000000 00000000 00000000 00000001
						printf("d3 = %d\n", d3);
						// 00000000 00000000 00000000 00000011 d
						// 00000000 00000000 00000000 00000101 d2
						// 00000000 00000000 00000000 00000001 d3计算结果

						// 按(二进制)位或 - 有1则1，同时为0则0
						int d4 = d | d2;
						printf("d4 = %d\n", d4);
						// 00000000 00000000 00000000 00000011 d
						// 00000000 00000000 00000000 00000101 d2
						// 00000000 00000000 00000000 00000111 d4计算结果

						// 按(二进制)位异或 - 对应的二进制位异或 - 相同为0，相异为1
						int d5 = d ^ d2;
						printf("d5 = %d\n", d5);
						// 00000000 00000000 00000000 00000011 d
						// 00000000 00000000 00000000 00000101 d2
						// 00000000 00000000 00000000 00000110 d5计算结果

					------------------------------------------

					赋值操作符
						基本赋值运算符：
							=

						复合赋值运算符：
							+=（加赋值）
							-=（减赋值）
							*=（乘赋值）
							/=（除赋值）
							％=（求余赋值）
							<<=（左移赋值）
							>>=（右移赋值）
							&=（按位与赋值）
							|=（按位或赋值）
							^=（按位异或赋值）


						连续赋值
							int a = 10;
							int x - 0;
							int y = 20;
							a = x = y + 1;// y+1赋值给x，x再赋值给a。最终x和a都是y+1的值

							同样语义
								x = y + 1;
								a = x;

					------------------------------------------

					单目操作符
						只有一个操作数

						！		逻辑反操作
						-		负值
						+		正值
						&		取地址
						sizeof	计算操作数的类型长度(以字节为单位)
						~		对一个数的二进制按位取反
						--		前置、后置--
						++		前置、后置++
						*		间接访问操作符(解引用操作符)
						(类型)	强制类型转换



						！		逻辑反操作
							int flag = 0;
							// flag为真打印hehe
							if (flag)
							{
								printf("hehe\n");
							}
							// flag为假打印haha
							if (!flag)
							{
								printf("haha\n");
							}
							// !可以让假变真 真变假
							printf("%d\n", !flag);


						-		负值
							int a = 10;
							a = -a;
							printf("%d\n", a);


						sizeof	计算操作数的类型长度(以字节为单位)
							int b = 10;
							char arr[66] = { 0 };
							int arr2[66] = { 0 };
							printf("b = %d\n", sizeof(b));// 计算b所占空间的大小，单位字节
							printf("b = %d\n", sizeof b);// 计算变量时括号可以省略，说明sizeof是一个操作符 不是函数

							printf("类型int = %d\n", sizeof(int));// 计算类型所占空间大小，单位字节

							printf("数组arr = %d\n", sizeof(arr));// 一个char 1字节 66个就66字节
							printf("数组arr2 = %d\n", sizeof(arr2));// 一个int  4字节

							printf("数组类型int = %d\n", sizeof(int [10]));// int [10] 是数组类型


						~		对一个数的二进制按位取反
							int e = -1;// -1在内存中存的是补码
							// 原码 10000000 00000000 00000000 00000001
							// 反码 11111111 11111111 11111111 11111110
							// 补码 11111111 11111111 11111111 11111111
							//
							// 按(二进制)位取反 包括符号位
							int f = ~e;
							printf("f = %d\n", f);


						--		前置、后置--
							int g = 10;
							int h = g++;// 后置++，先使用 再++
							printf("g = %d\n", g);
							printf("h = %d\n", h);

							int g2 = 10;
							int h2 = ++g2;// 前置++，先++ 再使用
							printf("g2 = %d\n", g2);
							printf("h2 = %d\n", h2);

*/

#include "define.h"

int main()
{
	// 将13的二进制 第5位改成1		 ↓
	// 00000000 00000000 00000000 00001101
	// 或上一个						 |
	// 00000000 00000000 00000000 00010000
	// 00000000 00000000 00000000 00011101
	int a = 13;
	// 制造出 00000000 00000000 00000000 00010000
	a = a | (1 << 4);
	printf("a = %d\n", a);

	// 把13的二进制 第5位改成0		 ↓
	// 00000000 00000000 00000000 00011101
	// 与上一个						 &
	// 11111111 11111111 11111111 11101111
	// 
	// 想要得到
	// 11111111 11111111 11111111 11101111
	// 
	// 就给
	// 00000000 00000000 00000000 00010000
	// 按位取反 就得到				 ~
	// 11111111 11111111 11111111 11101111
	// 
	a = a & ~(1 << 4);
	printf("a = %d\n", a);








	int flag = 0;
	// flag为真打印hehe
	if (flag)
	{
		printf("hehe\n");
	}
	// flag为假打印haha
	if (!flag)
	{
		printf("haha\n");
	}
	// !可以让假变真 真变假
	printf("%d\n", !flag);










	int b = 10;
	char arr[66] = { 0 };
	int arr2[66] = { 0 };
	printf("b = %d\n", sizeof(b));// 计算b所占空间的大小，单位字节
	printf("b = %d\n", sizeof b);// 计算变量时括号可以省略，说明sizeof是一个操作符 不是函数

	printf("类型int = %d\n", sizeof(int));// 计算类型所占空间大小，单位字节

	printf("数组arr = %d\n", sizeof(arr));// 一个char 1字节 66个就66字节
	printf("数组arr2 = %d\n", sizeof(arr2));// 一个int  4字节

	printf("数组类型int = %d\n", sizeof(int [10]));// int [10] 是数组类型


	short c = 5;// 短整形 占2字节
	int d = 10;
	printf("%d\n", sizeof(c = d + 2));// 表达式结果放在c，计算c的大小
	printf("c = %d\n", c);
	// sizeof括号中放的表达式是不参与运算的 

	// test.c ---------------→ test.exe
	// 源文件				   可执行程序
	// 编译			链接		   运行
	// c = d + 2在编译期间处理
	// 编译期间根据这个表达式d + 2的结果放到了c里，结果c说了算，c所占空间大小是2，sizeof计算结果是2
	// 运行期间c = d + 2就没了
	// 
	// 会有整型提升，不过需要把表达式拿出来算完之后再sizeof（c）就是4










	int e = -1;// -1在内存中存的是补码
	// 原码 10000000 00000000 00000000 00000001
	// 反码 11111111 11111111 11111111 11111110
	// 补码 11111111 11111111 11111111 11111111
	// 
	// 按(二进制)位取反 包括符号位
	int f = ~e;
	printf("f = %d\n", f);










	int g = 10;
	int h = g++;// 后置++，先使用 再++
	printf("g = %d\n", g);
	printf("h = %d\n", h);

	int g2 = 10;
	int h2 = ++g2;// 前置++，先++ 再使用
	printf("g2 = %d\n", g2);
	printf("h2 = %d\n", h2);














	return 0;
}