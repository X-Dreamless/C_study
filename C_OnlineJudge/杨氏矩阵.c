/*
	杨氏矩阵
		有一个数字矩阵，矩阵的每行从左到右是递增的，矩阵从上到下是递增的，
		编写程序在这样的矩阵中查找某个数字是否存在

		要求：时间复杂度小于O(N);

		(
		有一个二维数组. 数组的每行从左到右是递增的，每列从上到下是递增的，
		在这样的数组中查找一个数字是否存在。 时间复杂度小于O(N);
		)
		―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
		时间复杂度小于O(N);
			如果数组里面有N个元素，在解决问题的时候，最坏的查找次数是N次 等于 O(N)

			N*N 等于 O(N^2)

		O(1)
			时间复杂度和N没关系，不是2N也不是3N......
			可能只是3次5次......，是一个常数字
		―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
		[1][2][3]
		[4][5][6]
		[7][8][9]
		---------------------------------------------------------------
		       ↓  右上角的元素，一行内最大，一列内最小
		[1][2][3]
		[4][5][6]
		[7][8][9]

		右上角的元素3和 要查找的元素7 比较
		3 < 7，3已经是一行内最大的元素了，3的左边肯定是没有比7大的了
		所以可以去掉一行
		
		[4][5][6]
		[7][8][9]
		---------------------------------------------------------------
			   ↓  右上角的元素，一行内最大，一列内最小
		[4][5][6]
		[7][8][9]

		右上角的元素6和 要查找的元素7 比较
		6 < 7，6已经是一行内最大的元素了，6的左边肯定是没有比7大的了
		所以可以去掉一行

		[7][8][9]
		---------------------------------------------------------------
			   ↓  右上角的元素，一行内最大，一列内最小
		[7][8][9]

		这一列里面只有一个元素9
		右上角的元素9和 要查找的元素7 比较
		9 > 7，将元素9的这一列去掉

		[7][8]
		---------------------------------------------------------------
		    ↓  右上角的元素，一行内最大，一列内最小
		[7][8]

		这一列里面只有一个元素8
		右上角的元素8和 要查找的元素7 比较
		8 > 7，将元素8的这一列去掉

		[7]
		---------------------------------------------------------------
		---------------------------------------------------------------
		用左下角的元素来比较也可也
		―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
*/

#include <stdio.h>

/**************************************************************************************************************************************************/

int 发现数字(int arr[3][3], int 行, int 列, int k)
{
	int x = 0;
	int y = 列 - 1;

	while (x < 行 && y >= 0)
	{
		if (arr[x][y] < k)
		{
			x++;// 去掉一行
		}
		else if(arr[x][y] > k)
		{
			y--;// 去掉一列
		}
		else
		{
			return 1;// 找到了
		}
	}
	return 0;// 找不到
}

void test1()
{
	int arr[3][3] = { 1,2,3,4,5,6,7,8,9 };

	// 查找一个数字，比如：7
	// 可以遍历，但是不满足要求：时间复杂度小于O(N);
	// 如果找到返回1，找不到返回0
	int k = 7;
	int ret = 发现数字(arr, 3, 3, k);
	if (ret == 1)
	{
		printf("找到了\n");
	}
	else
	{
		printf("找不到\n");
	}
}

/**************************************************************************************************************************************************/
/****************/
/* 找到返回坐标 */
/***************/
int 发现数字2(int arr[3][3], int* 行, int* 列, int k)
{
	int x = 0;
	int y = *列 - 1;

	while (x < *行 && y >= 0)
	{
		if (arr[x][y] < k)
		{
			x++;// 去掉一行
		}
		else if (arr[x][y] > k)
		{
			y--;// 去掉一列
		}
		else
		{
			*行 = x;
			*列 = y;
			return 1;// 找到了
		}
	}
	return 0;// 找不到
}

void test2()
{
	int arr[3][3] = { 1,2,3,4,5,6,7,8,9 };

	// 查找一个数字，比如：7
	// 可以遍历，但是不满足要求：时间复杂度小于O(N);
	// 如果找到返回1，找不到返回0
	int k = 7;

	int x = 3;
	int y = 3;
	// &x &y
	// 1.传入参数
	// 2.带回值

	int ret = 发现数字2(arr, &x, &y, k);
	if (ret == 1)
	{
		printf("找到了\n");
		printf("下标是：%d %d\n", x, y);
	}
	else
	{
		printf("找不到\n");
	}

}

/**************************************************************************************************************************************************/

int main()
{
	//test1();

	test2();

	return 0;
}